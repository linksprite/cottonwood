; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\psock.o --depend=.\Obj\psock.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\psock.crf ..\..\Libraries\uIP-1.0\uip\psock.c]
                          THUMB

                          AREA ||i.buf_bufdata||, CODE, READONLY, ALIGN=1

                  buf_bufdata PROC
;;;82     static u8_t
;;;83     buf_bufdata(struct psock_buf *buf, u16_t len,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     	    u8_t **dataptr, u16_t *datalen)
;;;85     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;86       if(*datalen < buf->left) {
00000c  8830              LDRH     r0,[r6,#0]
00000e  88a1              LDRH     r1,[r4,#4]
000010  4288              CMP      r0,r1
000012  da14              BGE      |L1.62|
;;;87         memcpy(buf->ptr, *dataptr, *datalen);
000014  8832              LDRH     r2,[r6,#0]
000016  6829              LDR      r1,[r5,#0]
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       __aeabi_memcpy
;;;88         buf->ptr += *datalen;
00001e  8831              LDRH     r1,[r6,#0]
000020  6820              LDR      r0,[r4,#0]
000022  4408              ADD      r0,r0,r1
000024  6020              STR      r0,[r4,#0]
;;;89         buf->left -= *datalen;
000026  88a0              LDRH     r0,[r4,#4]
000028  8831              LDRH     r1,[r6,#0]
00002a  1a40              SUBS     r0,r0,r1
00002c  80a0              STRH     r0,[r4,#4]
;;;90         *dataptr += *datalen;
00002e  8831              LDRH     r1,[r6,#0]
000030  6828              LDR      r0,[r5,#0]
000032  4408              ADD      r0,r0,r1
000034  6028              STR      r0,[r5,#0]
;;;91         *datalen = 0;
000036  2000              MOVS     r0,#0
000038  8030              STRH     r0,[r6,#0]
                  |L1.58|
;;;92         return BUF_NOT_FULL;
;;;93       } else if(*datalen == buf->left) {
;;;94         memcpy(buf->ptr, *dataptr, *datalen);
;;;95         buf->ptr += *datalen;
;;;96         buf->left = 0;
;;;97         *dataptr += *datalen;
;;;98         *datalen = 0;
;;;99         return BUF_FULL;
;;;100      } else {
;;;101        memcpy(buf->ptr, *dataptr, buf->left);
;;;102        buf->ptr += buf->left;
;;;103        *datalen -= buf->left;
;;;104        *dataptr += buf->left;
;;;105        buf->left = 0;
;;;106        return BUF_FULL;
;;;107      }
;;;108    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.62|
00003e  8830              LDRH     r0,[r6,#0]            ;93
000040  88a1              LDRH     r1,[r4,#4]            ;93
000042  4288              CMP      r0,r1                 ;93
000044  d112              BNE      |L1.108|
000046  8832              LDRH     r2,[r6,#0]            ;94
000048  6829              LDR      r1,[r5,#0]            ;94
00004a  6820              LDR      r0,[r4,#0]            ;94
00004c  f7fffffe          BL       __aeabi_memcpy
000050  8831              LDRH     r1,[r6,#0]            ;95
000052  6820              LDR      r0,[r4,#0]            ;95
000054  4408              ADD      r0,r0,r1              ;95
000056  6020              STR      r0,[r4,#0]            ;95
000058  2000              MOVS     r0,#0                 ;96
00005a  80a0              STRH     r0,[r4,#4]            ;96
00005c  8831              LDRH     r1,[r6,#0]            ;97
00005e  6828              LDR      r0,[r5,#0]            ;97
000060  4408              ADD      r0,r0,r1              ;97
000062  6028              STR      r0,[r5,#0]            ;97
000064  2000              MOVS     r0,#0                 ;98
000066  8030              STRH     r0,[r6,#0]            ;98
000068  2001              MOVS     r0,#1                 ;99
00006a  e7e6              B        |L1.58|
                  |L1.108|
00006c  88a2              LDRH     r2,[r4,#4]            ;101
00006e  6829              LDR      r1,[r5,#0]            ;101
000070  6820              LDR      r0,[r4,#0]            ;101
000072  f7fffffe          BL       __aeabi_memcpy
000076  88a1              LDRH     r1,[r4,#4]            ;102
000078  6820              LDR      r0,[r4,#0]            ;102
00007a  4408              ADD      r0,r0,r1              ;102
00007c  6020              STR      r0,[r4,#0]            ;102
00007e  8830              LDRH     r0,[r6,#0]            ;103
000080  88a1              LDRH     r1,[r4,#4]            ;103
000082  1a40              SUBS     r0,r0,r1              ;103
000084  8030              STRH     r0,[r6,#0]            ;103
000086  88a1              LDRH     r1,[r4,#4]            ;104
000088  6828              LDR      r0,[r5,#0]            ;104
00008a  4408              ADD      r0,r0,r1              ;104
00008c  6028              STR      r0,[r5,#0]            ;104
00008e  2000              MOVS     r0,#0                 ;105
000090  80a0              STRH     r0,[r4,#4]            ;105
000092  2001              MOVS     r0,#1                 ;106
000094  e7d1              B        |L1.58|
;;;109    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.buf_bufto||, CODE, READONLY, ALIGN=1

                  buf_bufto PROC
;;;110    static u8_t
;;;111    buf_bufto(register struct psock_buf *buf, u8_t endmarker,
000000  b530              PUSH     {r4,r5,lr}
;;;112    	  register u8_t **dataptr, register u16_t *datalen)
;;;113    {
000002  4605              MOV      r5,r0
;;;114      u8_t c;
;;;115      while(buf->left > 0 && *datalen > 0) {
000004  e013              B        |L2.46|
                  |L2.6|
;;;116        c = *buf->ptr = **dataptr;
000006  6810              LDR      r0,[r2,#0]
000008  7804              LDRB     r4,[r0,#0]
00000a  6828              LDR      r0,[r5,#0]
00000c  7004              STRB     r4,[r0,#0]
;;;117        ++*dataptr;
00000e  6810              LDR      r0,[r2,#0]
000010  1c40              ADDS     r0,r0,#1
000012  6010              STR      r0,[r2,#0]
;;;118        ++buf->ptr;
000014  6828              LDR      r0,[r5,#0]
000016  1c40              ADDS     r0,r0,#1
000018  6028              STR      r0,[r5,#0]
;;;119        --*datalen;
00001a  8818              LDRH     r0,[r3,#0]
00001c  1e40              SUBS     r0,r0,#1
00001e  8018              STRH     r0,[r3,#0]
;;;120        --buf->left;
000020  88a8              LDRH     r0,[r5,#4]
000022  1e40              SUBS     r0,r0,#1
000024  80a8              STRH     r0,[r5,#4]
;;;121    
;;;122        if(c == endmarker) {
000026  428c              CMP      r4,r1
000028  d101              BNE      |L2.46|
;;;123          return BUF_FOUND;
00002a  2002              MOVS     r0,#2
                  |L2.44|
;;;124        }
;;;125      }
;;;126    
;;;127      if(*datalen == 0) {
;;;128        return BUF_NOT_FOUND;
;;;129      }
;;;130    
;;;131      while(*datalen > 0) {
;;;132        c = **dataptr;
;;;133        --*datalen;
;;;134        ++*dataptr;
;;;135    
;;;136        if(c == endmarker) {
;;;137          return BUF_FOUND | BUF_FULL;
;;;138        }
;;;139      }
;;;140    
;;;141      return BUF_FULL;
;;;142    }
00002c  bd30              POP      {r4,r5,pc}
                  |L2.46|
00002e  88a8              LDRH     r0,[r5,#4]            ;115
000030  2800              CMP      r0,#0                 ;115
000032  dd02              BLE      |L2.58|
000034  8818              LDRH     r0,[r3,#0]            ;115
000036  2800              CMP      r0,#0                 ;115
000038  dce5              BGT      |L2.6|
                  |L2.58|
00003a  8818              LDRH     r0,[r3,#0]            ;127
00003c  b908              CBNZ     r0,|L2.66|
00003e  2000              MOVS     r0,#0                 ;128
000040  e7f4              B        |L2.44|
                  |L2.66|
000042  e00b              B        |L2.92|
                  |L2.68|
000044  6810              LDR      r0,[r2,#0]            ;132
000046  7804              LDRB     r4,[r0,#0]            ;132
000048  8818              LDRH     r0,[r3,#0]            ;133
00004a  1e40              SUBS     r0,r0,#1              ;133
00004c  8018              STRH     r0,[r3,#0]            ;133
00004e  6810              LDR      r0,[r2,#0]            ;134
000050  1c40              ADDS     r0,r0,#1              ;134
000052  6010              STR      r0,[r2,#0]            ;134
000054  428c              CMP      r4,r1                 ;136
000056  d101              BNE      |L2.92|
000058  2003              MOVS     r0,#3                 ;137
00005a  e7e7              B        |L2.44|
                  |L2.92|
00005c  8818              LDRH     r0,[r3,#0]            ;131
00005e  2800              CMP      r0,#0                 ;131
000060  dcf0              BGT      |L2.68|
000062  2001              MOVS     r0,#1                 ;141
000064  e7e2              B        |L2.44|
;;;143    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.buf_setup||, CODE, READONLY, ALIGN=1

                  buf_setup PROC
;;;74     static void
;;;75     buf_setup(struct psock_buf *buf,
000000  6001              STR      r1,[r0,#0]
;;;76     	  u8_t *bufptr, u16_t bufsize)
;;;77     {
;;;78       buf->ptr = bufptr;
;;;79       buf->left = bufsize;
000002  8082              STRH     r2,[r0,#4]
;;;80     }
000004  4770              BX       lr
;;;81     /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.data_acked||, CODE, READONLY, ALIGN=2

                  data_acked PROC
;;;159    static char
;;;160    data_acked(register struct psock *s)
000000  4601              MOV      r1,r0
;;;161    {
;;;162      if(s->state == STATE_DATA_SENT && uip_acked()) {
000002  f8910020          LDRB     r0,[r1,#0x20]
000006  2806              CMP      r0,#6
000008  d121              BNE      |L4.78|
00000a  4812              LDR      r0,|L4.84|
00000c  7800              LDRB     r0,[r0,#0]  ; uip_flags
00000e  f0100f01          TST      r0,#1
000012  d01c              BEQ      |L4.78|
;;;163        if(s->sendlen > uip_mss()) {
000014  8a08              LDRH     r0,[r1,#0x10]
000016  4a10              LDR      r2,|L4.88|
000018  6812              LDR      r2,[r2,#0]  ; uip_conn
00001a  8a52              LDRH     r2,[r2,#0x12]
00001c  4290              CMP      r0,r2
00001e  dd0c              BLE      |L4.58|
;;;164          s->sendlen -= uip_mss();
000020  8a08              LDRH     r0,[r1,#0x10]
000022  4a0d              LDR      r2,|L4.88|
000024  6812              LDR      r2,[r2,#0]  ; uip_conn
000026  8a52              LDRH     r2,[r2,#0x12]
000028  1a80              SUBS     r0,r0,r2
00002a  8208              STRH     r0,[r1,#0x10]
;;;165          s->sendptr += uip_mss();
00002c  4a0a              LDR      r2,|L4.88|
00002e  6848              LDR      r0,[r1,#4]
000030  6812              LDR      r2,[r2,#0]  ; uip_conn
000032  8a52              LDRH     r2,[r2,#0x12]
000034  4410              ADD      r0,r0,r2
000036  6048              STR      r0,[r1,#4]
000038  e005              B        |L4.70|
                  |L4.58|
;;;166        } else {
;;;167          s->sendptr += s->sendlen;
00003a  8a0a              LDRH     r2,[r1,#0x10]
00003c  6848              LDR      r0,[r1,#4]
00003e  4410              ADD      r0,r0,r2
000040  6048              STR      r0,[r1,#4]
;;;168          s->sendlen = 0;
000042  2000              MOVS     r0,#0
000044  8208              STRH     r0,[r1,#0x10]
                  |L4.70|
;;;169        }
;;;170        s->state = STATE_ACKED;
000046  2001              MOVS     r0,#1
000048  f8810020          STRB     r0,[r1,#0x20]
                  |L4.76|
;;;171        return 1;
;;;172      }
;;;173      return 0;
;;;174    }
00004c  4770              BX       lr
                  |L4.78|
00004e  2000              MOVS     r0,#0                 ;173
000050  e7fc              B        |L4.76|
;;;175    /*---------------------------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L4.84|
                          DCD      uip_flags
                  |L4.88|
                          DCD      uip_conn

                          AREA ||i.psock_datalen||, CODE, READONLY, ALIGN=1

                  psock_datalen PROC
;;;246    u16_t
;;;247    psock_datalen(struct psock *psock)
000000  4601              MOV      r1,r0
;;;248    {
;;;249      return psock->bufsize - psock->buf.left;
000002  8b08              LDRH     r0,[r1,#0x18]
000004  69ca              LDR      r2,[r1,#0x1c]
000006  1a10              SUBS     r0,r2,r0
000008  b280              UXTH     r0,r0
;;;250    }
00000a  4770              BX       lr
;;;251    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.psock_generator_send||, CODE, READONLY, ALIGN=2

                  psock_generator_send PROC
;;;214    /*---------------------------------------------------------------------------*/
;;;215    PT_THREAD(psock_generator_send(register struct psock *s,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216    			       unsigned short (*generate)(void *), void *arg))
;;;217    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;218      PT_BEGIN(&s->psockpt);
00000a  2701              MOVS     r7,#1
00000c  8860              LDRH     r0,[r4,#2]
00000e  b110              CBZ      r0,|L6.22|
000010  28ee              CMP      r0,#0xee
000012  d130              BNE      |L6.118|
000014  e02e              B        |L6.116|
                  |L6.22|
;;;219    
;;;220      /* Ensure that there is a generator function to call. */
;;;221      if(generate == NULL) {
000016  b92d              CBNZ     r5,|L6.36|
;;;222        PT_EXIT(&s->psockpt);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  8060              STRH     r0,[r4,#2]
00001e  2001              MOVS     r0,#1
                  |L6.32|
;;;223      }
;;;224    
;;;225      /* Call the generator function to generate the data in the
;;;226         uip_appdata buffer. */
;;;227      s->sendlen = generate(arg);
;;;228      s->sendptr = uip_appdata;
;;;229    
;;;230      s->state = STATE_NONE;
;;;231      do {
;;;232        /* Call the generator function again if we are called to perform a
;;;233           retransmission. */
;;;234        if(uip_rexmit()) {
;;;235          generate(arg);
;;;236        }
;;;237        /* Wait until all data is sent and acknowledged. */
;;;238        PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
;;;239      } while(s->sendlen > 0);
;;;240    
;;;241      s->state = STATE_NONE;
;;;242    
;;;243      PT_END(&s->psockpt);
;;;244    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L6.36|
000024  4630              MOV      r0,r6                 ;227
000026  47a8              BLX      r5                    ;227
000028  8220              STRH     r0,[r4,#0x10]         ;227
00002a  4816              LDR      r0,|L6.132|
00002c  6800              LDR      r0,[r0,#0]            ;228  ; uip_appdata
00002e  6060              STR      r0,[r4,#4]            ;228
000030  2000              MOVS     r0,#0                 ;230
000032  f8840020          STRB     r0,[r4,#0x20]         ;230
000036  bf00              NOP                            ;231
                  |L6.56|
000038  4813              LDR      r0,|L6.136|
00003a  7800              LDRB     r0,[r0,#0]            ;234  ; uip_flags
00003c  f0100f04          TST      r0,#4                 ;234
000040  d001              BEQ      |L6.70|
000042  4630              MOV      r0,r6                 ;235
000044  47a8              BLX      r5                    ;235
                  |L6.70|
000046  bf00              NOP                            ;238
000048  20ee              MOVS     r0,#0xee              ;238
00004a  8060              STRH     r0,[r4,#2]            ;238
                  |L6.76|
00004c  4620              MOV      r0,r4                 ;238
00004e  f7fffffe          BL       data_acked
000052  4680              MOV      r8,r0                 ;238
000054  4620              MOV      r0,r4                 ;238
000056  f7fffffe          BL       send_data
00005a  ea180f00          TST      r8,r0                 ;238
00005e  d101              BNE      |L6.100|
000060  2000              MOVS     r0,#0                 ;238
000062  e7dd              B        |L6.32|
                  |L6.100|
000064  bf00              NOP                            ;238
000066  8a20              LDRH     r0,[r4,#0x10]         ;239
000068  2800              CMP      r0,#0                 ;239
00006a  dce5              BGT      |L6.56|
00006c  2000              MOVS     r0,#0                 ;241
00006e  f8840020          STRB     r0,[r4,#0x20]         ;241
000072  e000              B        |L6.118|
                  |L6.116|
000074  e7ea              B        |L6.76|
                  |L6.118|
000076  bf00              NOP                            ;218
000078  2700              MOVS     r7,#0                 ;243
00007a  2000              MOVS     r0,#0                 ;243
00007c  8060              STRH     r0,[r4,#2]            ;243
00007e  2002              MOVS     r0,#2                 ;243
000080  e7ce              B        |L6.32|
;;;245    /*---------------------------------------------------------------------------*/
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      uip_appdata
                  |L6.136|
                          DCD      uip_flags

                          AREA ||i.psock_init||, CODE, READONLY, ALIGN=1

                  psock_init PROC
;;;327    void
;;;328    psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
000000  b570              PUSH     {r4-r6,lr}
;;;329    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;330      psock->state = STATE_NONE;
000008  2000              MOVS     r0,#0
00000a  f8840020          STRB     r0,[r4,#0x20]
;;;331      psock->readlen = 0;
00000e  8260              STRH     r0,[r4,#0x12]
;;;332      psock->bufptr = buffer;
000010  60e5              STR      r5,[r4,#0xc]
;;;333      psock->bufsize = buffersize;
000012  61e6              STR      r6,[r4,#0x1c]
;;;334      buf_setup(&psock->buf, buffer, buffersize);
000014  b2b2              UXTH     r2,r6
000016  4629              MOV      r1,r5
000018  f1040014          ADD      r0,r4,#0x14
00001c  f7fffffe          BL       buf_setup
;;;335      PT_INIT(&psock->pt);
000020  2000              MOVS     r0,#0
000022  8020              STRH     r0,[r4,#0]
;;;336      PT_INIT(&psock->psockpt);
000024  8060              STRH     r0,[r4,#2]
;;;337    }
000026  bd70              POP      {r4-r6,pc}
;;;338    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.psock_newdata||, CODE, READONLY, ALIGN=2

                  psock_newdata PROC
;;;252    char
;;;253    psock_newdata(struct psock *s)
000000  4601              MOV      r1,r0
;;;254    {
;;;255      if(s->readlen > 0) {
000002  8a48              LDRH     r0,[r1,#0x12]
000004  2800              CMP      r0,#0
000006  dd01              BLE      |L8.12|
;;;256        /* There is data in the uip_appdata buffer that has not yet been
;;;257           read with the PSOCK_READ functions. */
;;;258        return 1;
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;259      } else if(s->state == STATE_READ) {
;;;260        /* All data in uip_appdata buffer already consumed. */
;;;261        s->state = STATE_BLOCKED_NEWDATA;
;;;262        return 0;
;;;263      } else if(uip_newdata()) {
;;;264        /* There is new data that has not been consumed. */
;;;265        return 1;
;;;266      } else {
;;;267        /* There is no new data. */
;;;268        return 0;
;;;269      }
;;;270    }
00000a  4770              BX       lr
                  |L8.12|
00000c  f8910020          LDRB     r0,[r1,#0x20]         ;259
000010  2802              CMP      r0,#2                 ;259
000012  d104              BNE      |L8.30|
000014  2003              MOVS     r0,#3                 ;261
000016  f8810020          STRB     r0,[r1,#0x20]         ;261
00001a  2000              MOVS     r0,#0                 ;262
00001c  e7f5              B        |L8.10|
                  |L8.30|
00001e  4804              LDR      r0,|L8.48|
000020  7800              LDRB     r0,[r0,#0]            ;263  ; uip_flags
000022  f0100f02          TST      r0,#2                 ;263
000026  d001              BEQ      |L8.44|
000028  2001              MOVS     r0,#1                 ;265
00002a  e7ee              B        |L8.10|
                  |L8.44|
00002c  2000              MOVS     r0,#0                 ;268
00002e  e7ec              B        |L8.10|
;;;271    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L8.48|
                          DCD      uip_flags

                          AREA ||i.psock_readbuf||, CODE, READONLY, ALIGN=2

                  psock_readbuf PROC
;;;298    /*---------------------------------------------------------------------------*/
;;;299    PT_THREAD(psock_readbuf(register struct psock *psock))
000000  b570              PUSH     {r4-r6,lr}
;;;300    {
000002  4604              MOV      r4,r0
;;;301      PT_BEGIN(&psock->psockpt);
000004  2501              MOVS     r5,#1
000006  8860              LDRH     r0,[r4,#2]
000008  b118              CBZ      r0,|L9.18|
00000a  f5b07f9b          CMP      r0,#0x136
00000e  d138              BNE      |L9.130|
000010  e036              B        |L9.128|
                  |L9.18|
;;;302    
;;;303      buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
000012  69e0              LDR      r0,[r4,#0x1c]
000014  b282              UXTH     r2,r0
000016  f1040014          ADD      r0,r4,#0x14
00001a  68e1              LDR      r1,[r4,#0xc]
00001c  f7fffffe          BL       buf_setup
;;;304    
;;;305      /* XXX: Should add buf_checkmarker() before do{} loop, if
;;;306         incoming data has been handled while waiting for a write. */
;;;307    
;;;308      do {
000020  bf00              NOP      
                  |L9.34|
;;;309        if(psock->readlen == 0) {
000022  8a60              LDRH     r0,[r4,#0x12]
000024  b9b0              CBNZ     r0,|L9.84|
;;;310          PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
000026  bf00              NOP      
000028  f44f709b          MOV      r0,#0x136
00002c  8060              STRH     r0,[r4,#2]
                  |L9.46|
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       psock_newdata
000034  b908              CBNZ     r0,|L9.58|
000036  2000              MOVS     r0,#0
                  |L9.56|
;;;311          printf("Waited for newdata\n");
;;;312          psock->state = STATE_READ;
;;;313          psock->readptr = (u8_t *)uip_appdata;
;;;314          psock->readlen = uip_datalen();
;;;315        }
;;;316      } while(buf_bufdata(&psock->buf, psock->bufsize,
;;;317    			 &psock->readptr,
;;;318    			 &psock->readlen) != BUF_FULL);
;;;319    
;;;320      if(psock_datalen(psock) == 0) {
;;;321        psock->state = STATE_NONE;
;;;322        PT_RESTART(&psock->psockpt);
;;;323      }
;;;324      PT_END(&psock->psockpt);
;;;325    }
000038  bd70              POP      {r4-r6,pc}
                  |L9.58|
00003a  bf00              NOP                            ;310
00003c  a014              ADR      r0,|L9.144|
00003e  f7fffffe          BL       __2printf
000042  2002              MOVS     r0,#2                 ;312
000044  f8840020          STRB     r0,[r4,#0x20]         ;312
000048  4816              LDR      r0,|L9.164|
00004a  6800              LDR      r0,[r0,#0]            ;313  ; uip_appdata
00004c  60a0              STR      r0,[r4,#8]            ;313
00004e  4816              LDR      r0,|L9.168|
000050  8800              LDRH     r0,[r0,#0]            ;314  ; uip_len
000052  8260              STRH     r0,[r4,#0x12]         ;314
                  |L9.84|
000054  69e0              LDR      r0,[r4,#0x1c]         ;316
000056  b281              UXTH     r1,r0                 ;316
000058  f1040312          ADD      r3,r4,#0x12           ;316
00005c  f1040208          ADD      r2,r4,#8              ;316
000060  1c98              ADDS     r0,r3,#2              ;316
000062  f7fffffe          BL       buf_bufdata
000066  2801              CMP      r0,#1                 ;316
000068  d1db              BNE      |L9.34|
00006a  4620              MOV      r0,r4                 ;320
00006c  f7fffffe          BL       psock_datalen
000070  b928              CBNZ     r0,|L9.126|
000072  2000              MOVS     r0,#0                 ;321
000074  f8840020          STRB     r0,[r4,#0x20]         ;321
000078  bf00              NOP                            ;322
00007a  8060              STRH     r0,[r4,#2]            ;322
00007c  e7dc              B        |L9.56|
                  |L9.126|
00007e  e000              B        |L9.130|
                  |L9.128|
000080  e7d5              B        |L9.46|
                  |L9.130|
000082  bf00              NOP                            ;301
000084  2500              MOVS     r5,#0                 ;324
000086  2000              MOVS     r0,#0                 ;324
000088  8060              STRH     r0,[r4,#2]            ;324
00008a  2002              MOVS     r0,#2                 ;324
00008c  e7d4              B        |L9.56|
;;;326    /*---------------------------------------------------------------------------*/
                          ENDP

00008e  0000              DCW      0x0000
                  |L9.144|
000090  57616974656420666f72206e6577646174610a00        DCB      "Waited for newdata\n",0
                  |L9.164|
                          DCD      uip_appdata
                  |L9.168|
                          DCD      uip_len

                          AREA ||i.psock_readto||, CODE, READONLY, ALIGN=2

                  psock_readto PROC
;;;271    /*---------------------------------------------------------------------------*/
;;;272    PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
000000  b570              PUSH     {r4-r6,lr}
;;;273    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;274      PT_BEGIN(&psock->psockpt);
000006  2601              MOVS     r6,#1
000008  8860              LDRH     r0,[r4,#2]
00000a  b120              CBZ      r0,|L10.22|
00000c  f5a07080          SUB      r0,r0,#0x100
000010  381b              SUBS     r0,r0,#0x1b
000012  d135              BNE      |L10.128|
000014  e033              B        |L10.126|
                  |L10.22|
;;;275    
;;;276      buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
000016  69e0              LDR      r0,[r4,#0x1c]
000018  b282              UXTH     r2,r0
00001a  f1040014          ADD      r0,r4,#0x14
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       buf_setup
;;;277    
;;;278      /* XXX: Should add buf_checkmarker() before do{} loop, if
;;;279         incoming data has been handled while waiting for a write. */
;;;280    
;;;281      do {
000024  bf00              NOP      
                  |L10.38|
;;;282        if(psock->readlen == 0) {
000026  8a60              LDRH     r0,[r4,#0x12]
000028  b998              CBNZ     r0,|L10.82|
;;;283          PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
00002a  bf00              NOP      
00002c  f240101b          MOV      r0,#0x11b
000030  8060              STRH     r0,[r4,#2]
                  |L10.50|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       psock_newdata
000038  b908              CBNZ     r0,|L10.62|
00003a  2000              MOVS     r0,#0
                  |L10.60|
;;;284          psock->state = STATE_READ;
;;;285          psock->readptr = (u8_t *)uip_appdata;
;;;286          psock->readlen = uip_datalen();
;;;287        }
;;;288      } while((buf_bufto(&psock->buf, c,
;;;289    		     &psock->readptr,
;;;290    		     &psock->readlen) & BUF_FOUND) == 0);
;;;291    
;;;292      if(psock_datalen(psock) == 0) {
;;;293        psock->state = STATE_NONE;
;;;294        PT_RESTART(&psock->psockpt);
;;;295      }
;;;296      PT_END(&psock->psockpt);
;;;297    }
00003c  bd70              POP      {r4-r6,pc}
                  |L10.62|
00003e  bf00              NOP                            ;283
000040  2002              MOVS     r0,#2                 ;284
000042  f8840020          STRB     r0,[r4,#0x20]         ;284
000046  4811              LDR      r0,|L10.140|
000048  6800              LDR      r0,[r0,#0]            ;285  ; uip_appdata
00004a  60a0              STR      r0,[r4,#8]            ;285
00004c  4810              LDR      r0,|L10.144|
00004e  8800              LDRH     r0,[r0,#0]            ;286  ; uip_len
000050  8260              STRH     r0,[r4,#0x12]         ;286
                  |L10.82|
000052  f1040312          ADD      r3,r4,#0x12           ;288
000056  f1040208          ADD      r2,r4,#8              ;288
00005a  4629              MOV      r1,r5                 ;288
00005c  1c98              ADDS     r0,r3,#2              ;288
00005e  f7fffffe          BL       buf_bufto
000062  f0100f02          TST      r0,#2                 ;288
000066  d0de              BEQ      |L10.38|
000068  4620              MOV      r0,r4                 ;292
00006a  f7fffffe          BL       psock_datalen
00006e  b928              CBNZ     r0,|L10.124|
000070  2000              MOVS     r0,#0                 ;293
000072  f8840020          STRB     r0,[r4,#0x20]         ;293
000076  bf00              NOP                            ;294
000078  8060              STRH     r0,[r4,#2]            ;294
00007a  e7df              B        |L10.60|
                  |L10.124|
00007c  e000              B        |L10.128|
                  |L10.126|
00007e  e7d8              B        |L10.50|
                  |L10.128|
000080  bf00              NOP                            ;274
000082  2600              MOVS     r6,#0                 ;296
000084  2000              MOVS     r0,#0                 ;296
000086  8060              STRH     r0,[r4,#2]            ;296
000088  2002              MOVS     r0,#2                 ;296
00008a  e7d7              B        |L10.60|
;;;298    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L10.140|
                          DCD      uip_appdata
                  |L10.144|
                          DCD      uip_len

                          AREA ||i.psock_send||, CODE, READONLY, ALIGN=1

                  psock_send PROC
;;;175    /*---------------------------------------------------------------------------*/
;;;176    PT_THREAD(psock_send(register struct psock *s, const char *buf,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;177    		     unsigned int len))
;;;178    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;179      PT_BEGIN(&s->psockpt);
00000a  2701              MOVS     r7,#1
00000c  8860              LDRH     r0,[r4,#2]
00000e  b110              CBZ      r0,|L11.22|
000010  28cf              CMP      r0,#0xcf
000012  d125              BNE      |L11.96|
000014  e023              B        |L11.94|
                  |L11.22|
;;;180    
;;;181      /* If there is no data to send, we exit immediately. */
;;;182      if(len == 0) {
000016  b92e              CBNZ     r6,|L11.36|
;;;183        PT_EXIT(&s->psockpt);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  8060              STRH     r0,[r4,#2]
00001e  2001              MOVS     r0,#1
                  |L11.32|
;;;184      }
;;;185    
;;;186      /* Save the length of and a pointer to the data that is to be
;;;187         sent. */
;;;188      s->sendptr = buf;
;;;189      s->sendlen = len;
;;;190    
;;;191      s->state = STATE_NONE;
;;;192    
;;;193      /* We loop here until all data is sent. The s->sendlen variable is
;;;194         updated by the data_sent() function. */
;;;195      while(s->sendlen > 0) {
;;;196    
;;;197        /*
;;;198         * The condition for this PT_WAIT_UNTIL is a little tricky: the
;;;199         * protothread will wait here until all data has been acknowledged
;;;200         * (data_acked() returns true) and until all data has been sent
;;;201         * (send_data() returns true). The two functions data_acked() and
;;;202         * send_data() must be called in succession to ensure that all
;;;203         * data is sent. Therefore the & operator is used instead of the
;;;204         * && operator, which would cause only the data_acked() function
;;;205         * to be called when it returns false.
;;;206         */
;;;207        PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
;;;208      }
;;;209    
;;;210      s->state = STATE_NONE;
;;;211    
;;;212      PT_END(&s->psockpt);
;;;213    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L11.36|
000024  6065              STR      r5,[r4,#4]            ;188
000026  8226              STRH     r6,[r4,#0x10]         ;189
000028  2000              MOVS     r0,#0                 ;191
00002a  f8840020          STRB     r0,[r4,#0x20]         ;191
00002e  e00f              B        |L11.80|
                  |L11.48|
000030  bf00              NOP                            ;207
000032  20cf              MOVS     r0,#0xcf              ;207
000034  8060              STRH     r0,[r4,#2]            ;207
                  |L11.54|
000036  4620              MOV      r0,r4                 ;207
000038  f7fffffe          BL       data_acked
00003c  4680              MOV      r8,r0                 ;207
00003e  4620              MOV      r0,r4                 ;207
000040  f7fffffe          BL       send_data
000044  ea180f00          TST      r8,r0                 ;207
000048  d101              BNE      |L11.78|
00004a  2000              MOVS     r0,#0                 ;207
00004c  e7e8              B        |L11.32|
                  |L11.78|
00004e  bf00              NOP                            ;207
                  |L11.80|
000050  8a20              LDRH     r0,[r4,#0x10]         ;195
000052  2800              CMP      r0,#0                 ;195
000054  dcec              BGT      |L11.48|
000056  2000              MOVS     r0,#0                 ;210
000058  f8840020          STRB     r0,[r4,#0x20]         ;210
00005c  e000              B        |L11.96|
                  |L11.94|
00005e  e7ea              B        |L11.54|
                  |L11.96|
000060  bf00              NOP                            ;179
000062  2700              MOVS     r7,#0                 ;212
000064  2000              MOVS     r0,#0                 ;212
000066  8060              STRH     r0,[r4,#2]            ;212
000068  2002              MOVS     r0,#2                 ;212
00006a  e7d9              B        |L11.32|
;;;214    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.send_data||, CODE, READONLY, ALIGN=2

                  send_data PROC
;;;144    static char
;;;145    send_data(register struct psock *s)
000000  b510              PUSH     {r4,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147      if(s->state != STATE_DATA_SENT || uip_rexmit()) {
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2806              CMP      r0,#6
00000a  d104              BNE      |L12.22|
00000c  480e              LDR      r0,|L12.72|
00000e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000010  f0100f04          TST      r0,#4
000014  d015              BEQ      |L12.66|
                  |L12.22|
;;;148        if(s->sendlen > uip_mss()) {
000016  8a20              LDRH     r0,[r4,#0x10]
000018  490c              LDR      r1,|L12.76|
00001a  6809              LDR      r1,[r1,#0]  ; uip_conn
00001c  8a49              LDRH     r1,[r1,#0x12]
00001e  4288              CMP      r0,r1
000020  dd06              BLE      |L12.48|
;;;149          uip_send(s->sendptr, uip_mss());
000022  4a0a              LDR      r2,|L12.76|
000024  6812              LDR      r2,[r2,#0]  ; uip_conn
000026  8a51              LDRH     r1,[r2,#0x12]
000028  6860              LDR      r0,[r4,#4]
00002a  f7fffffe          BL       uip_send
00002e  e003              B        |L12.56|
                  |L12.48|
;;;150        } else {
;;;151          uip_send(s->sendptr, s->sendlen);
000030  8a21              LDRH     r1,[r4,#0x10]
000032  6860              LDR      r0,[r4,#4]
000034  f7fffffe          BL       uip_send
                  |L12.56|
;;;152        }
;;;153        s->state = STATE_DATA_SENT;
000038  2006              MOVS     r0,#6
00003a  f8840020          STRB     r0,[r4,#0x20]
;;;154        return 1;
00003e  2001              MOVS     r0,#1
                  |L12.64|
;;;155      }
;;;156      return 0;
;;;157    }
000040  bd10              POP      {r4,pc}
                  |L12.66|
000042  2000              MOVS     r0,#0                 ;156
000044  e7fc              B        |L12.64|
;;;158    /*---------------------------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L12.72|
                          DCD      uip_flags
                  |L12.76|
                          DCD      uip_conn
