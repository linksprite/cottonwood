; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\ip_arp_udp_tcp.o --depend=.\Obj\ip_arp_udp_tcp.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\ip_arp_udp_tcp.crf ..\..\Source\src\uIP_enc28j60\ip_arp_udp_tcp.c]
                          THUMB

                          AREA ||i.checksum||, CODE, READONLY, ALIGN=1

                  checksum PROC
;;;39     // The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
;;;40     unsigned  int checksum(unsigned char *buf, unsigned  int len,unsigned char type)
000000  b530              PUSH     {r4,r5,lr}
;;;41     	{
000002  4603              MOV      r3,r0
;;;42     	// type 0=ip 
;;;43     	//      1=udp
;;;44     	//      2=tcp
;;;45     	unsigned long sum = 0;
000004  2400              MOVS     r4,#0
;;;46     	
;;;47     	//if(type==0){
;;;48     	//        // do not add anything
;;;49     	//}
;;;50     	if(type==1)
000006  2a01              CMP      r2,#1
000008  d103              BNE      |L1.18|
;;;51     		{
;;;52     		sum+=IP_PROTO_UDP_V; // protocol udp
00000a  3411              ADDS     r4,r4,#0x11
;;;53     		// the length here is the length of udp (data+header len)
;;;54     		// =length given to this function - (IP.scr+IP.dst length)
;;;55     		sum+=len-8; // = real tcp len
00000c  f1a10008          SUB      r0,r1,#8
000010  4404              ADD      r4,r4,r0
                  |L1.18|
;;;56     		}
;;;57     	if(type==2)
000012  2a02              CMP      r2,#2
000014  d103              BNE      |L1.30|
;;;58     		{
;;;59     		sum+=IP_PROTO_TCP_V; 
000016  1da4              ADDS     r4,r4,#6
;;;60     		// the length here is the length of tcp (data+header len)
;;;61     		// =length given to this function - (IP.scr+IP.dst length)
;;;62     		sum+=len-8; // = real tcp len
000018  f1a10008          SUB      r0,r1,#8
00001c  4404              ADD      r4,r4,r0
                  |L1.30|
;;;63     		}
;;;64     	// build the sum of 16bit words
;;;65     	while(len >1)
00001e  e006              B        |L1.46|
                  |L1.32|
;;;66     		{
;;;67     		sum += 0xFFFF & (*buf<<8|*(buf+1));
000020  7858              LDRB     r0,[r3,#1]
000022  781d              LDRB     r5,[r3,#0]
000024  ea402005          ORR      r0,r0,r5,LSL #8
000028  4404              ADD      r4,r4,r0
;;;68     		buf+=2;
00002a  1c9b              ADDS     r3,r3,#2
;;;69     		len-=2;
00002c  1e89              SUBS     r1,r1,#2
                  |L1.46|
00002e  2901              CMP      r1,#1                 ;65
000030  d8f6              BHI      |L1.32|
;;;70     		}
;;;71     	// if there is a byte left then add it (padded with zero)
;;;72     	if (len)
000032  b111              CBZ      r1,|L1.58|
;;;73     		{
;;;74     		sum += (0xFF & *buf)<<8;
000034  7818              LDRB     r0,[r3,#0]
000036  eb042400          ADD      r4,r4,r0,LSL #8
                  |L1.58|
;;;75     		}
;;;76     	// now calculate the sum over the bytes in the sum
;;;77     	// until the result is only 16bit long
;;;78     	while (sum>>16)
00003a  e002              B        |L1.66|
                  |L1.60|
;;;79     		{
;;;80     		sum = (sum & 0xFFFF)+(sum >> 16);
00003c  b2a0              UXTH     r0,r4
00003e  eb004414          ADD      r4,r0,r4,LSR #16
                  |L1.66|
000042  0c20              LSRS     r0,r4,#16             ;78
000044  d1fa              BNE      |L1.60|
;;;81     		}
;;;82     	// build 1's complement:
;;;83     	return( (unsigned  int) sum ^ 0xFFFF);
000046  f64f75ff          MOV      r5,#0xffff
00004a  ea840005          EOR      r0,r4,r5
;;;84     	}
00004e  bd30              POP      {r4,r5,pc}
;;;85     
                          ENDP


                          AREA ||i.eth_type_is_arp_and_my_ip||, CODE, READONLY, ALIGN=2

                  eth_type_is_arp_and_my_ip PROC
;;;103    
;;;104    unsigned char eth_type_is_arp_and_my_ip(unsigned char *buf,unsigned  int len)
000000  b510              PUSH     {r4,lr}
;;;105    	{
000002  4603              MOV      r3,r0
;;;106    	unsigned char i=0;
000004  2200              MOVS     r2,#0
;;;107    	//  
;;;108    	if (len<41)
000006  2929              CMP      r1,#0x29
000008  d201              BCS      |L2.14|
;;;109    		{
;;;110    	    return(0);
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;111    		}
;;;112    	if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V)
;;;113    		{
;;;114    	    return(0);
;;;115    		}
;;;116    	while(i<4)
;;;117    		{
;;;118    	    if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i])
;;;119    			{
;;;120    	        return(0);
;;;121    	    	}
;;;122    	    i++;
;;;123    		}
;;;124    	return(1);
;;;125    	}
00000c  bd10              POP      {r4,pc}
                  |L2.14|
00000e  7b18              LDRB     r0,[r3,#0xc]          ;112
000010  2808              CMP      r0,#8                 ;112
000012  d102              BNE      |L2.26|
000014  7b58              LDRB     r0,[r3,#0xd]          ;112
000016  2806              CMP      r0,#6                 ;112
000018  d001              BEQ      |L2.30|
                  |L2.26|
00001a  2000              MOVS     r0,#0                 ;114
00001c  e7f6              B        |L2.12|
                  |L2.30|
00001e  e00a              B        |L2.54|
                  |L2.32|
000020  f1020026          ADD      r0,r2,#0x26           ;118
000024  5c18              LDRB     r0,[r3,r0]            ;118
000026  4c06              LDR      r4,|L2.64|
000028  5ca4              LDRB     r4,[r4,r2]            ;118
00002a  42a0              CMP      r0,r4                 ;118
00002c  d001              BEQ      |L2.50|
00002e  2000              MOVS     r0,#0                 ;120
000030  e7ec              B        |L2.12|
                  |L2.50|
000032  1c50              ADDS     r0,r2,#1              ;122
000034  b2c2              UXTB     r2,r0                 ;122
                  |L2.54|
000036  2a04              CMP      r2,#4                 ;116
000038  dbf2              BLT      |L2.32|
00003a  2001              MOVS     r0,#1                 ;124
00003c  e7e6              B        |L2.12|
;;;126    
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      ||.data||+0x13

                          AREA ||i.eth_type_is_ip_and_my_ip||, CODE, READONLY, ALIGN=2

                  eth_type_is_ip_and_my_ip PROC
;;;126    
;;;127    unsigned char eth_type_is_ip_and_my_ip(unsigned char *buf,unsigned  int len)
000000  b510              PUSH     {r4,lr}
;;;128    	{
000002  4603              MOV      r3,r0
;;;129    	unsigned char i=0;
000004  2200              MOVS     r2,#0
;;;130    	//eth+ip+udp header is 42
;;;131    	if (len<42)
000006  292a              CMP      r1,#0x2a
000008  d201              BCS      |L3.14|
;;;132    		{
;;;133    	    return(0);
00000a  2000              MOVS     r0,#0
                  |L3.12|
;;;134    		}
;;;135    	if(buf[ETH_TYPE_H_P]!=ETHTYPE_IP_H_V || buf[ETH_TYPE_L_P]!=ETHTYPE_IP_L_V)
;;;136    		{
;;;137    	    return(0);
;;;138    		}
;;;139    	if (buf[IP_HEADER_LEN_VER_P]!=0x45)
;;;140    		{
;;;141    	    // must be IP V4 and 20 byte header
;;;142    	    return(0);
;;;143    		}
;;;144    	while(i<4)
;;;145    		{
;;;146    	    if(buf[IP_DST_P+i]!=ipaddr[i])
;;;147    			{
;;;148    	        return(0);
;;;149    	    	}
;;;150    	    i++;
;;;151    		}
;;;152    	return(1);
;;;153    	}
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  7b18              LDRB     r0,[r3,#0xc]          ;135
000010  2808              CMP      r0,#8                 ;135
000012  d101              BNE      |L3.24|
000014  7b58              LDRB     r0,[r3,#0xd]          ;135
000016  b108              CBZ      r0,|L3.28|
                  |L3.24|
000018  2000              MOVS     r0,#0                 ;137
00001a  e7f7              B        |L3.12|
                  |L3.28|
00001c  7b98              LDRB     r0,[r3,#0xe]          ;139
00001e  2845              CMP      r0,#0x45              ;139
000020  d001              BEQ      |L3.38|
000022  2000              MOVS     r0,#0                 ;142
000024  e7f2              B        |L3.12|
                  |L3.38|
000026  e00a              B        |L3.62|
                  |L3.40|
000028  f102001e          ADD      r0,r2,#0x1e           ;146
00002c  5c18              LDRB     r0,[r3,r0]            ;146
00002e  4c06              LDR      r4,|L3.72|
000030  5ca4              LDRB     r4,[r4,r2]            ;146
000032  42a0              CMP      r0,r4                 ;146
000034  d001              BEQ      |L3.58|
000036  2000              MOVS     r0,#0                 ;148
000038  e7e8              B        |L3.12|
                  |L3.58|
00003a  1c50              ADDS     r0,r2,#1              ;150
00003c  b2c2              UXTB     r2,r0                 ;150
                  |L3.62|
00003e  2a04              CMP      r2,#4                 ;144
000040  dbf2              BLT      |L3.40|
000042  2001              MOVS     r0,#1                 ;152
000044  e7e2              B        |L3.12|
;;;154    // make a return eth header from a received eth packet
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      ||.data||+0x13

                          AREA ||i.fill_ip_hdr_checksum||, CODE, READONLY, ALIGN=1

                  fill_ip_hdr_checksum PROC
;;;166    	}
;;;167    void fill_ip_hdr_checksum(unsigned char *buf)
000000  b530              PUSH     {r4,r5,lr}
;;;168    	{
000002  4604              MOV      r4,r0
;;;169    	unsigned  int ck;
;;;170    	// clear the 2 byte checksum
;;;171    	buf[IP_CHECKSUM_P]=0;
000004  2000              MOVS     r0,#0
000006  7620              STRB     r0,[r4,#0x18]
;;;172    	buf[IP_CHECKSUM_P+1]=0;
000008  7660              STRB     r0,[r4,#0x19]
;;;173    	buf[IP_FLAGS_P]=0x40; // don't fragment
00000a  2040              MOVS     r0,#0x40
00000c  7520              STRB     r0,[r4,#0x14]
;;;174    	buf[IP_FLAGS_P+1]=0;  // fragement offset
00000e  2000              MOVS     r0,#0
000010  7560              STRB     r0,[r4,#0x15]
;;;175    	buf[IP_TTL_P]=64; // ttl
000012  2040              MOVS     r0,#0x40
000014  75a0              STRB     r0,[r4,#0x16]
;;;176    	// calculate the checksum:
;;;177    	ck=checksum(&buf[IP_P], IP_HEADER_LEN,0);
000016  2200              MOVS     r2,#0
000018  2114              MOVS     r1,#0x14
00001a  f104000e          ADD      r0,r4,#0xe
00001e  f7fffffe          BL       checksum
000022  4605              MOV      r5,r0
;;;178    	buf[IP_CHECKSUM_P]=ck>>8;
000024  0a28              LSRS     r0,r5,#8
000026  7620              STRB     r0,[r4,#0x18]
;;;179    	buf[IP_CHECKSUM_P+1]=ck& 0xff;
000028  7665              STRB     r5,[r4,#0x19]
;;;180    	}
00002a  bd30              POP      {r4,r5,pc}
;;;181    
                          ENDP


                          AREA ||i.fill_tcp_data||, CODE, READONLY, ALIGN=1

                  fill_tcp_data PROC
;;;419    // this string could be filled.
;;;420    unsigned  int fill_tcp_data(unsigned char *buf,unsigned  int pos, const char *s)
000000  b510              PUSH     {r4,lr}
;;;421    	{
000002  4603              MOV      r3,r0
;;;422    	// fill in tcp data at position pos
;;;423    	//
;;;424    	// with no options the data starts after the checksum + 2 more bytes (urgent ptr)
;;;425    	while (*s) 
000004  e005              B        |L5.18|
                  |L5.6|
;;;426    		{
;;;427    	    buf[TCP_CHECKSUM_L_P+3+pos]=*s;
000006  7814              LDRB     r4,[r2,#0]
000008  f1010036          ADD      r0,r1,#0x36
00000c  541c              STRB     r4,[r3,r0]
;;;428    	    pos++;
00000e  1c49              ADDS     r1,r1,#1
;;;429    	    s++;
000010  1c52              ADDS     r2,r2,#1
                  |L5.18|
000012  7810              LDRB     r0,[r2,#0]            ;425
000014  2800              CMP      r0,#0                 ;425
000016  d1f6              BNE      |L5.6|
;;;430    		}
;;;431    	return(pos);
000018  4608              MOV      r0,r1
;;;432    	}
00001a  bd10              POP      {r4,pc}
;;;433    
                          ENDP


                          AREA ||i.fill_tcp_data_p||, CODE, READONLY, ALIGN=1

                  fill_tcp_data_p PROC
;;;402    // this string could be filled.
;;;403    unsigned  int fill_tcp_data_p(unsigned char *buf,unsigned  int pos, const unsigned char *progmem_s)
000000  b510              PUSH     {r4,lr}
;;;404    	{
000002  4603              MOV      r3,r0
;;;405    	char c;
;;;406    	// fill in tcp data at position pos
;;;407    	//
;;;408    	// with no options the data starts after the checksum + 2 more bytes (urgent ptr)
;;;409    	while ((c = pgm_read_byte(progmem_s++))) 
000004  e003              B        |L6.14|
                  |L6.6|
;;;410    		{
;;;411    	    buf[TCP_CHECKSUM_L_P+3+pos]=c;
000006  f1010036          ADD      r0,r1,#0x36
00000a  541c              STRB     r4,[r3,r0]
;;;412    	    pos++;
00000c  1c49              ADDS     r1,r1,#1
                  |L6.14|
00000e  f8124b01          LDRB     r4,[r2],#1            ;409
000012  2c00              CMP      r4,#0                 ;409
000014  d1f7              BNE      |L6.6|
;;;413    		}
;;;414    	return(pos);
000016  4608              MOV      r0,r1
;;;415    	}
000018  bd10              POP      {r4,pc}
;;;416    
                          ENDP


                          AREA ||i.get_tcp_data_pointer||, CODE, READONLY, ALIGN=2

                  get_tcp_data_pointer PROC
;;;374    // You must call init_len_info once before calling this function
;;;375    unsigned  int get_tcp_data_pointer(void)
000000  4804              LDR      r0,|L7.20|
;;;376    	{
;;;377    	if (info_data_len)
000002  6800              LDR      r0,[r0,#0]  ; info_data_len
000004  b120              CBZ      r0,|L7.16|
;;;378    			{
;;;379    	        return((unsigned  int)TCP_SRC_PORT_H_P+info_hdr_len);
000006  4803              LDR      r0,|L7.20|
000008  1f00              SUBS     r0,r0,#4
00000a  6800              LDR      r0,[r0,#0]  ; info_hdr_len
00000c  3022              ADDS     r0,r0,#0x22
                  |L7.14|
;;;380    			}
;;;381    		else
;;;382    			{
;;;383    	        return(0);
;;;384    			}
;;;385    	}
00000e  4770              BX       lr
                  |L7.16|
000010  2000              MOVS     r0,#0                 ;383
000012  e7fc              B        |L7.14|
;;;386    
                          ENDP

                  |L7.20|
                          DCD      ||.data||+0x8

                          AREA ||i.init_ip_arp_udp_tcp||, CODE, READONLY, ALIGN=2

                  init_ip_arp_udp_tcp PROC
;;;86     // you must call this function once before you use any of the other functions:
;;;87     void init_ip_arp_udp_tcp(unsigned char *mymac,unsigned char *myip,unsigned char wwwp)
000000  b530              PUSH     {r4,r5,lr}
;;;88     	{
;;;89     	unsigned char i=0;
000002  2300              MOVS     r3,#0
;;;90     	wwwport=wwwp;
000004  4c0a              LDR      r4,|L8.48|
000006  7022              STRB     r2,[r4,#0]
;;;91     	while(i<4)
000008  e005              B        |L8.22|
                  |L8.10|
;;;92     		{
;;;93             ipaddr[i]=myip[i];
00000a  5ccc              LDRB     r4,[r1,r3]
00000c  4d08              LDR      r5,|L8.48|
00000e  3513              ADDS     r5,r5,#0x13
000010  54ec              STRB     r4,[r5,r3]
;;;94             i++;
000012  1c5c              ADDS     r4,r3,#1
000014  b2e3              UXTB     r3,r4
                  |L8.22|
000016  2b04              CMP      r3,#4                 ;91
000018  dbf7              BLT      |L8.10|
;;;95     		}
;;;96     	i=0;
00001a  2300              MOVS     r3,#0
;;;97     	while(i<6)
00001c  e005              B        |L8.42|
                  |L8.30|
;;;98     		{
;;;99             macaddr[i]=mymac[i];
00001e  5cc4              LDRB     r4,[r0,r3]
000020  4d03              LDR      r5,|L8.48|
000022  350d              ADDS     r5,r5,#0xd
000024  54ec              STRB     r4,[r5,r3]
;;;100            i++;
000026  1c5c              ADDS     r4,r3,#1
000028  b2e3              UXTB     r3,r4
                  |L8.42|
00002a  2b06              CMP      r3,#6                 ;97
00002c  dbf7              BLT      |L8.30|
;;;101    		}
;;;102    	}
00002e  bd30              POP      {r4,r5,pc}
;;;103    
                          ENDP

                  |L8.48|
                          DCD      ||.data||

                          AREA ||i.init_len_info||, CODE, READONLY, ALIGN=2

                  init_len_info PROC
;;;387    // do some basic length calculations and store the result in static varibales
;;;388    void init_len_info(unsigned char *buf)
000000  7c02              LDRB     r2,[r0,#0x10]
;;;389    	{
;;;390        info_data_len=(buf[IP_TOTLEN_H_P]<<8)|(buf[IP_TOTLEN_L_P]&0xff);
000002  7c41              LDRB     r1,[r0,#0x11]
000004  f362211f          BFI      r1,r2,#8,#24
000008  4a0b              LDR      r2,|L9.56|
00000a  6011              STR      r1,[r2,#0]  ; info_data_len
;;;391        info_data_len-=IP_HEADER_LEN;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]  ; info_data_len
000010  3914              SUBS     r1,r1,#0x14
000012  6011              STR      r1,[r2,#0]  ; info_data_len
;;;392        info_hdr_len=(buf[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
000014  f890102e          LDRB     r1,[r0,#0x2e]
000018  1109              ASRS     r1,r1,#4
00001a  0089              LSLS     r1,r1,#2
00001c  1f12              SUBS     r2,r2,#4
00001e  6011              STR      r1,[r2,#0]  ; info_hdr_len
;;;393        info_data_len-=info_hdr_len;
000020  1d11              ADDS     r1,r2,#4
000022  6809              LDR      r1,[r1,#0]  ; info_data_len
000024  6812              LDR      r2,[r2,#0]  ; info_hdr_len
000026  1a89              SUBS     r1,r1,r2
000028  4a03              LDR      r2,|L9.56|
00002a  6011              STR      r1,[r2,#0]  ; info_data_len
;;;394        if (info_data_len<=0)
00002c  4611              MOV      r1,r2
00002e  6809              LDR      r1,[r1,#0]  ; info_data_len
000030  b909              CBNZ     r1,|L9.54|
;;;395    		{
;;;396            info_data_len=0;
000032  2100              MOVS     r1,#0
000034  6011              STR      r1,[r2,#0]  ; info_data_len
                  |L9.54|
;;;397        	}
;;;398    	}
000036  4770              BX       lr
;;;399    
                          ENDP

                  |L9.56|
                          DCD      ||.data||+0x8

                          AREA ||i.make_arp_answer_from_request||, CODE, READONLY, ALIGN=2

                  make_arp_answer_from_request PROC
;;;274    
;;;275    void make_arp_answer_from_request(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;276    	{
000002  4605              MOV      r5,r0
;;;277    	unsigned char i=0;
000004  2400              MOVS     r4,#0
;;;278    	//
;;;279    	make_eth(buf);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       make_eth
;;;280    	buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;   //arp ÏìÓ¦
00000c  2000              MOVS     r0,#0
00000e  7528              STRB     r0,[r5,#0x14]
;;;281    	buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
000010  2002              MOVS     r0,#2
000012  7568              STRB     r0,[r5,#0x15]
;;;282    	// fill the mac addresses:
;;;283    	while(i<6)
000014  e00b              B        |L10.46|
                  |L10.22|
;;;284    		{
;;;285            buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
000016  f1040016          ADD      r0,r4,#0x16
00001a  5c29              LDRB     r1,[r5,r0]
00001c  300a              ADDS     r0,r0,#0xa
00001e  5429              STRB     r1,[r5,r0]
;;;286            buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
000020  480f              LDR      r0,|L10.96|
000022  5d01              LDRB     r1,[r0,r4]
000024  f1040016          ADD      r0,r4,#0x16
000028  5429              STRB     r1,[r5,r0]
;;;287            i++;
00002a  1c60              ADDS     r0,r4,#1
00002c  b2c4              UXTB     r4,r0
                  |L10.46|
00002e  2c06              CMP      r4,#6                 ;283
000030  dbf1              BLT      |L10.22|
;;;288    		}
;;;289    	i=0;
000032  2400              MOVS     r4,#0
;;;290    	while(i<4)
000034  e00c              B        |L10.80|
                  |L10.54|
;;;291    		{
;;;292            buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
000036  f104001c          ADD      r0,r4,#0x1c
00003a  5c29              LDRB     r1,[r5,r0]
00003c  300a              ADDS     r0,r0,#0xa
00003e  5429              STRB     r1,[r5,r0]
;;;293            buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
000040  4807              LDR      r0,|L10.96|
000042  1d80              ADDS     r0,r0,#6
000044  5d01              LDRB     r1,[r0,r4]
000046  f104001c          ADD      r0,r4,#0x1c
00004a  5429              STRB     r1,[r5,r0]
;;;294            i++;
00004c  1c60              ADDS     r0,r4,#1
00004e  b2c4              UXTB     r4,r0
                  |L10.80|
000050  2c04              CMP      r4,#4                 ;290
000052  dbf0              BLT      |L10.54|
;;;295    		}
;;;296    	// eth+arp is 42 bytes:
;;;297    	enc28j60PacketSend(42,buf); 
000054  4629              MOV      r1,r5
000056  202a              MOVS     r0,#0x2a
000058  f7fffffe          BL       enc28j60PacketSend
;;;298    	}
00005c  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

00005e  0000              DCW      0x0000
                  |L10.96|
                          DCD      ||.data||+0xd

                          AREA ||i.make_echo_reply_from_request||, CODE, READONLY, ALIGN=1

                  make_echo_reply_from_request PROC
;;;299    
;;;300    void make_echo_reply_from_request(unsigned char *buf,unsigned  int len)
000000  b570              PUSH     {r4-r6,lr}
;;;301    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;302    	make_eth(buf);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       make_eth
;;;303    	make_ip(buf);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       make_ip
;;;304    	buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;	  //////»ØËÍÓ¦´ð////////////////////////////////////////////////////////////////////////////
000012  2000              MOVS     r0,#0
000014  f8840022          STRB     r0,[r4,#0x22]
;;;305    	// we changed only the icmp.type field from request(=8) to reply(=0).
;;;306    	// we can therefore easily correct the checksum:
;;;307    	if (buf[ICMP_CHECKSUM_P] > (0xff-0x08))
000018  f8940024          LDRB     r0,[r4,#0x24]
00001c  28f7              CMP      r0,#0xf7
00001e  dd04              BLE      |L11.42|
;;;308    		{
;;;309    	    buf[ICMP_CHECKSUM_P+1]++;
000020  f8940025          LDRB     r0,[r4,#0x25]
000024  1c40              ADDS     r0,r0,#1
000026  f8840025          STRB     r0,[r4,#0x25]
                  |L11.42|
;;;310    		}
;;;311    	buf[ICMP_CHECKSUM_P]+=0x08;
00002a  f8940024          LDRB     r0,[r4,#0x24]
00002e  3008              ADDS     r0,r0,#8
000030  f8840024          STRB     r0,[r4,#0x24]
;;;312    	//
;;;313    	enc28j60PacketSend(len,buf);
000034  4621              MOV      r1,r4
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       enc28j60PacketSend
;;;314    	}
00003c  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP


                          AREA ||i.make_eth||, CODE, READONLY, ALIGN=2

                  make_eth PROC
;;;154    // make a return eth header from a received eth packet
;;;155    void make_eth(unsigned char *buf)
000000  2100              MOVS     r1,#0
;;;156    	{
;;;157    	unsigned char i=0;
;;;158    	//
;;;159    	//copy the destination mac from the source and fill my mac into src
;;;160    	while(i<6)
000002  e008              B        |L12.22|
                  |L12.4|
;;;161    		{
;;;162            buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
000004  1d8a              ADDS     r2,r1,#6
000006  5c83              LDRB     r3,[r0,r2]
000008  5443              STRB     r3,[r0,r1]
;;;163            buf[ETH_SRC_MAC +i]=macaddr[i];
00000a  4a04              LDR      r2,|L12.28|
00000c  5c53              LDRB     r3,[r2,r1]
00000e  1d8a              ADDS     r2,r1,#6
000010  5483              STRB     r3,[r0,r2]
;;;164            i++;
000012  1c4a              ADDS     r2,r1,#1
000014  b2d1              UXTB     r1,r2
                  |L12.22|
000016  2906              CMP      r1,#6                 ;160
000018  dbf4              BLT      |L12.4|
;;;165    		}
;;;166    	}
00001a  4770              BX       lr
;;;167    void fill_ip_hdr_checksum(unsigned char *buf)
                          ENDP

                  |L12.28|
                          DCD      ||.data||+0xd

                          AREA ||i.make_ip||, CODE, READONLY, ALIGN=2

                  make_ip PROC
;;;182    // make a return ip header from a received ip packet
;;;183    void make_ip(unsigned char *buf)
000000  b530              PUSH     {r4,r5,lr}
;;;184    	{
000002  4605              MOV      r5,r0
;;;185    	unsigned char i=0;
000004  2400              MOVS     r4,#0
;;;186    	while(i<4)
000006  e00b              B        |L13.32|
                  |L13.8|
;;;187    		{
;;;188            buf[IP_DST_P+i]=buf[IP_SRC_P+i];
000008  f104001a          ADD      r0,r4,#0x1a
00000c  5c29              LDRB     r1,[r5,r0]
00000e  1d00              ADDS     r0,r0,#4
000010  5429              STRB     r1,[r5,r0]
;;;189            buf[IP_SRC_P+i]=ipaddr[i];
000012  4806              LDR      r0,|L13.44|
000014  5d01              LDRB     r1,[r0,r4]
000016  f104001a          ADD      r0,r4,#0x1a
00001a  5429              STRB     r1,[r5,r0]
;;;190            i++;
00001c  1c60              ADDS     r0,r4,#1
00001e  b2c4              UXTB     r4,r0
                  |L13.32|
000020  2c04              CMP      r4,#4                 ;186
000022  dbf1              BLT      |L13.8|
;;;191    		}
;;;192    	fill_ip_hdr_checksum(buf);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       fill_ip_hdr_checksum
;;;193    	}
00002a  bd30              POP      {r4,r5,pc}
;;;194    
                          ENDP

                  |L13.44|
                          DCD      ||.data||+0x13

                          AREA ||i.make_tcp_ack_from_any||, CODE, READONLY, ALIGN=2

                  make_tcp_ack_from_any PROC
;;;435    // This will modify the eth/ip/tcp header 
;;;436    void make_tcp_ack_from_any(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;437    	{
000002  4605              MOV      r5,r0
;;;438    	unsigned  int j;
;;;439    	make_eth(buf);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       make_eth
;;;440    	// fill the header:
;;;441    	buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V;
00000a  2010              MOVS     r0,#0x10
00000c  f885002f          STRB     r0,[r5,#0x2f]
;;;442    	if (info_data_len==0)
000010  4814              LDR      r0,|L14.100|
000012  6800              LDR      r0,[r0,#0]  ; info_data_len
000014  b930              CBNZ     r0,|L14.36|
;;;443    			{
;;;444    	        // if there is no data then we must still acknoledge one packet
;;;445    	        make_tcphead(buf,1,0,1); // no options
000016  2301              MOVS     r3,#1
000018  2200              MOVS     r2,#0
00001a  4619              MOV      r1,r3
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       make_tcphead
000022  e006              B        |L14.50|
                  |L14.36|
;;;446    			}
;;;447    		else
;;;448    			{
;;;449    	        make_tcphead(buf,info_data_len,0,1); // no options
000024  2301              MOVS     r3,#1
000026  2200              MOVS     r2,#0
000028  480e              LDR      r0,|L14.100|
00002a  6801              LDR      r1,[r0,#0]  ; info_data_len
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       make_tcphead
                  |L14.50|
;;;450    			}
;;;451    	
;;;452    	// total length field in the IP header must be set:
;;;453    	// 20 bytes IP + 20 bytes tcp (when no options) 
;;;454    	j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
000032  2428              MOVS     r4,#0x28
;;;455    	buf[IP_TOTLEN_H_P]=j>>8;
000034  0a20              LSRS     r0,r4,#8
000036  7428              STRB     r0,[r5,#0x10]
;;;456    	buf[IP_TOTLEN_L_P]=j& 0xff;
000038  746c              STRB     r4,[r5,#0x11]
;;;457    	make_ip(buf);
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       make_ip
;;;458    	// calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
;;;459    	j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
000040  2202              MOVS     r2,#2
000042  211c              MOVS     r1,#0x1c
000044  f105001a          ADD      r0,r5,#0x1a
000048  f7fffffe          BL       checksum
00004c  4604              MOV      r4,r0
;;;460    	buf[TCP_CHECKSUM_H_P]=j>>8;
00004e  0a20              LSRS     r0,r4,#8
000050  f8850032          STRB     r0,[r5,#0x32]
;;;461    	buf[TCP_CHECKSUM_L_P]=j& 0xff;
000054  f8854033          STRB     r4,[r5,#0x33]
;;;462    	enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
000058  4629              MOV      r1,r5
00005a  2036              MOVS     r0,#0x36
00005c  f7fffffe          BL       enc28j60PacketSend
;;;463    	}
000060  bd70              POP      {r4-r6,pc}
;;;464    
                          ENDP

000062  0000              DCW      0x0000
                  |L14.100|
                          DCD      ||.data||+0x8

                          AREA ||i.make_tcp_ack_with_data||, CODE, READONLY, ALIGN=1

                  make_tcp_ack_with_data PROC
;;;469    // length and checksum
;;;470    void make_tcp_ack_with_data(unsigned char *buf,unsigned  int dlen)
000000  b570              PUSH     {r4-r6,lr}
;;;471    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;472    	unsigned  int j;
;;;473    	// fill the header:
;;;474    	// This code requires that we send only one data packet
;;;475    	// because we keep no state information. We must therefore set
;;;476    	// the fin here:
;;;477    	buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
000006  2019              MOVS     r0,#0x19
000008  f884002f          STRB     r0,[r4,#0x2f]
;;;478    	
;;;479    	// total length field in the IP header must be set:
;;;480    	// 20 bytes IP + 20 bytes tcp (when no options) + len of data
;;;481    	j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
00000c  f1050628          ADD      r6,r5,#0x28
;;;482    	buf[IP_TOTLEN_H_P]=j>>8;
000010  0a30              LSRS     r0,r6,#8
000012  7420              STRB     r0,[r4,#0x10]
;;;483    	buf[IP_TOTLEN_L_P]=j& 0xff;
000014  7466              STRB     r6,[r4,#0x11]
;;;484    	fill_ip_hdr_checksum(buf);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       fill_ip_hdr_checksum
;;;485    	// zero the checksum
;;;486    	buf[TCP_CHECKSUM_H_P]=0;
00001c  2000              MOVS     r0,#0
00001e  f8840032          STRB     r0,[r4,#0x32]
;;;487    	buf[TCP_CHECKSUM_L_P]=0;
000022  f8840033          STRB     r0,[r4,#0x33]
;;;488    	// calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
;;;489    	j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
000026  f105011c          ADD      r1,r5,#0x1c
00002a  2202              MOVS     r2,#2
00002c  f104001a          ADD      r0,r4,#0x1a
000030  f7fffffe          BL       checksum
000034  4606              MOV      r6,r0
;;;490    	buf[TCP_CHECKSUM_H_P]=j>>8;
000036  0a30              LSRS     r0,r6,#8
000038  f8840032          STRB     r0,[r4,#0x32]
;;;491    	buf[TCP_CHECKSUM_L_P]=j& 0xff;
00003c  f8846033          STRB     r6,[r4,#0x33]
;;;492    	enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
000040  f1050036          ADD      r0,r5,#0x36
000044  4621              MOV      r1,r4
000046  f7fffffe          BL       enc28j60PacketSend
;;;493    	}
00004a  bd70              POP      {r4-r6,pc}
;;;494    
                          ENDP


                          AREA ||i.make_tcp_synack_from_syn||, CODE, READONLY, ALIGN=1

                  make_tcp_synack_from_syn PROC
;;;352    
;;;353    void make_tcp_synack_from_syn(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;354    	{
000002  4604              MOV      r4,r0
;;;355    	unsigned  int ck;
;;;356    	make_eth(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       make_eth
;;;357    	// total length field in the IP header must be set:
;;;358    	// 20 bytes IP + 24 bytes (20tcp+4tcp options)
;;;359    	buf[IP_TOTLEN_H_P]=0;
00000a  2000              MOVS     r0,#0
00000c  7420              STRB     r0,[r4,#0x10]
;;;360    	buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
00000e  202c              MOVS     r0,#0x2c
000010  7460              STRB     r0,[r4,#0x11]
;;;361    	make_ip(buf);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       make_ip
;;;362    	buf[TCP_FLAGS_P]=TCP_FLAGS_SYNACK_V;
000018  2012              MOVS     r0,#0x12
00001a  f884002f          STRB     r0,[r4,#0x2f]
;;;363    	make_tcphead(buf,1,1,0);
00001e  2300              MOVS     r3,#0
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       make_tcphead
;;;364    	// calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
;;;365    	ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
00002a  2202              MOVS     r2,#2
00002c  2120              MOVS     r1,#0x20
00002e  f104001a          ADD      r0,r4,#0x1a
000032  f7fffffe          BL       checksum
000036  4605              MOV      r5,r0
;;;366    	buf[TCP_CHECKSUM_H_P]=ck>>8;
000038  0a28              LSRS     r0,r5,#8
00003a  f8840032          STRB     r0,[r4,#0x32]
;;;367    	buf[TCP_CHECKSUM_L_P]=ck& 0xff;
00003e  f8845033          STRB     r5,[r4,#0x33]
;;;368    	// add 4 for option mss:
;;;369    	enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
000042  4621              MOV      r1,r4
000044  203a              MOVS     r0,#0x3a
000046  f7fffffe          BL       enc28j60PacketSend
;;;370    	}
00004a  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP


                          AREA ||i.make_tcphead||, CODE, READONLY, ALIGN=2

                  make_tcphead PROC
;;;202    // otherwise it is copied from the packet we received
;;;203    void make_tcphead(unsigned char *buf,unsigned  int rel_ack_num,unsigned char mss,unsigned char cp_seq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;204    	{
;;;205    	unsigned char i=0;
000002  2400              MOVS     r4,#0
;;;206    	unsigned char tseq;
;;;207    	while(i<2)
000004  e009              B        |L17.26|
                  |L17.6|
;;;208    		{
;;;209    	    buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
000006  f1040622          ADD      r6,r4,#0x22
00000a  5d87              LDRB     r7,[r0,r6]
00000c  1cb6              ADDS     r6,r6,#2
00000e  5587              STRB     r7,[r0,r6]
;;;210    	    buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
000010  2700              MOVS     r7,#0
000012  1eb6              SUBS     r6,r6,#2
000014  5587              STRB     r7,[r0,r6]
;;;211    	    i++;
000016  1c66              ADDS     r6,r4,#1
000018  b2f4              UXTB     r4,r6
                  |L17.26|
00001a  2c02              CMP      r4,#2                 ;207
00001c  dbf3              BLT      |L17.6|
;;;212    		}
;;;213    	// set source port  (http):
;;;214    	buf[TCP_SRC_PORT_L_P]=wwwport;
00001e  4e22              LDR      r6,|L17.168|
000020  7836              LDRB     r6,[r6,#0]  ; wwwport
000022  f8806023          STRB     r6,[r0,#0x23]
;;;215    	i=4;
000026  2404              MOVS     r4,#4
;;;216    	// sequence numbers:
;;;217    	// add the rel ack num to SEQACK
;;;218    	while(i>0)
000028  e012              B        |L17.80|
                  |L17.42|
;;;219    		{
;;;220    	    rel_ack_num=buf[TCP_SEQ_H_P+i-1]+rel_ack_num;
00002a  f1040625          ADD      r6,r4,#0x25
00002e  5d86              LDRB     r6,[r0,r6]
000030  4431              ADD      r1,r1,r6
;;;221    	    tseq=buf[TCP_SEQACK_H_P+i-1];
000032  f1040629          ADD      r6,r4,#0x29
000036  5d85              LDRB     r5,[r0,r6]
;;;222    	    buf[TCP_SEQACK_H_P+i-1]=0xff&rel_ack_num;
000038  5581              STRB     r1,[r0,r6]
;;;223    	    if (cp_seq)
00003a  b113              CBZ      r3,|L17.66|
;;;224    				{
;;;225    		        // copy the acknum sent to us into the sequence number
;;;226    		        buf[TCP_SEQ_H_P+i-1]=tseq;
00003c  1f36              SUBS     r6,r6,#4
00003e  5585              STRB     r5,[r0,r6]
000040  e003              B        |L17.74|
                  |L17.66|
;;;227    		    	}
;;;228    			else
;;;229    				{
;;;230    	            buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
000042  2700              MOVS     r7,#0
000044  f1040625          ADD      r6,r4,#0x25
000048  5587              STRB     r7,[r0,r6]
                  |L17.74|
;;;231    	    		}
;;;232    	    rel_ack_num=rel_ack_num>>8;
00004a  0a09              LSRS     r1,r1,#8
;;;233    	    i--;
00004c  1e66              SUBS     r6,r4,#1
00004e  b2f4              UXTB     r4,r6
                  |L17.80|
000050  2c00              CMP      r4,#0                 ;218
000052  dcea              BGT      |L17.42|
;;;234    		}
;;;235    	if (cp_seq==0)
000054  b98b              CBNZ     r3,|L17.122|
;;;236    		{
;;;237    	    // put inital seq number
;;;238    	    buf[TCP_SEQ_H_P+0]= 0;
000056  2600              MOVS     r6,#0
000058  f8006f26          STRB     r6,[r0,#0x26]!
;;;239    	    buf[TCP_SEQ_H_P+1]= 0;
00005c  7046              STRB     r6,[r0,#1]
;;;240    	    // we step only the second byte, this allows us to send packts 
;;;241    	    // with 255 bytes or 512 (if we step the initial seqnum by 2)
;;;242    	    buf[TCP_SEQ_H_P+2]= seqnum; 
00005e  4e12              LDR      r6,|L17.168|
000060  360c              ADDS     r6,r6,#0xc
000062  7836              LDRB     r6,[r6,#0]  ; seqnum
000064  7086              STRB     r6,[r0,#2]
;;;243    	    buf[TCP_SEQ_H_P+3]= 0;
000066  2600              MOVS     r6,#0
000068  70c6              STRB     r6,[r0,#3]
00006a  3826              SUBS     r0,r0,#0x26
;;;244    	    // step the inititial seq num by something we will not use
;;;245    	    // during this tcp session:
;;;246    	    seqnum+=2;
00006c  4e0e              LDR      r6,|L17.168|
00006e  360c              ADDS     r6,r6,#0xc
000070  7836              LDRB     r6,[r6,#0]  ; seqnum
000072  1cb6              ADDS     r6,r6,#2
000074  4f0c              LDR      r7,|L17.168|
000076  370c              ADDS     r7,r7,#0xc
000078  703e              STRB     r6,[r7,#0]
                  |L17.122|
;;;247    		}
;;;248    	// zero the checksum
;;;249    	buf[TCP_CHECKSUM_H_P]=0;
00007a  2600              MOVS     r6,#0
00007c  f8806032          STRB     r6,[r0,#0x32]
;;;250    	buf[TCP_CHECKSUM_L_P]=0;
000080  f8806033          STRB     r6,[r0,#0x33]
;;;251    	
;;;252    	// The tcp header length is only a 4 bit field (the upper 4 bits).
;;;253    	// It is calculated in units of 4 bytes. 
;;;254    	// E.g 24 bytes: 24/4=6 => 0x60=header len field
;;;255    	//buf[TCP_HEADER_LEN_P]=(((TCP_HEADER_LEN_PLAIN+4)/4)) <<4; // 0x60
;;;256    	if (mss)
000084  b162              CBZ      r2,|L17.160|
;;;257    			{
;;;258    		    // the only option we set is MSS to 1408:
;;;259    		    // 1408 in hex is 0x580
;;;260    		    buf[TCP_OPTIONS_P]=2;
000086  2602              MOVS     r6,#2
000088  302e              ADDS     r0,r0,#0x2e
00008a  7206              STRB     r6,[r0,#8]
;;;261    		    buf[TCP_OPTIONS_P+1]=4;
00008c  2604              MOVS     r6,#4
00008e  7246              STRB     r6,[r0,#9]
;;;262    		    buf[TCP_OPTIONS_P+2]=0x05; 
000090  2605              MOVS     r6,#5
000092  7286              STRB     r6,[r0,#0xa]
;;;263    		    buf[TCP_OPTIONS_P+3]=0x80;
000094  2680              MOVS     r6,#0x80
000096  72c6              STRB     r6,[r0,#0xb]
;;;264    		    // 24 bytes:
;;;265    		    buf[TCP_HEADER_LEN_P]=0x60;
000098  2660              MOVS     r6,#0x60
00009a  f800692e          STRB     r6,[r0],#-0x2e
00009e  e002              B        |L17.166|
                  |L17.160|
;;;266    			}
;;;267    		else
;;;268    			{
;;;269    		    // no options:
;;;270    		    // 20 bytes:
;;;271    		    buf[TCP_HEADER_LEN_P]=0x50;
0000a0  2650              MOVS     r6,#0x50
0000a2  f880602e          STRB     r6,[r0,#0x2e]
                  |L17.166|
;;;272    			}
;;;273    	}
0000a6  bdf0              POP      {r4-r7,pc}
;;;274    
                          ENDP

                  |L17.168|
                          DCD      ||.data||

                          AREA ||i.make_udp_reply_from_request||, CODE, READONLY, ALIGN=1

                  make_udp_reply_from_request PROC
;;;316    // you can send a max of 220 bytes of data
;;;317    void make_udp_reply_from_request(unsigned char *buf,char *data,unsigned int datalen,unsigned  int port)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;318    	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;319    	unsigned int i=0;
00000c  f04f0800          MOV      r8,#0
;;;320    	unsigned  int ck;
;;;321    	make_eth(buf);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       make_eth
;;;322    	//if (datalen>220)
;;;323    	//	{
;;;324    	//    datalen=220;
;;;325    	//	}
;;;326    	
;;;327    	// total length field in the IP header must be set:
;;;328    	i= IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
000016  f106081c          ADD      r8,r6,#0x1c
;;;329    	buf[IP_TOTLEN_H_P]=i>>8;
00001a  ea4f2018          LSR      r0,r8,#8
00001e  7420              STRB     r0,[r4,#0x10]
;;;330    	buf[IP_TOTLEN_L_P]=i;
000020  f8848011          STRB     r8,[r4,#0x11]
;;;331    	make_ip(buf);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       make_ip
;;;332    	buf[UDP_DST_PORT_H_P]=port>>8;
00002a  0a38              LSRS     r0,r7,#8
00002c  f8040f24          STRB     r0,[r4,#0x24]!
;;;333    	buf[UDP_DST_PORT_L_P]=port & 0xff;
000030  7067              STRB     r7,[r4,#1]
;;;334    	// source port does not matter and is what the sender used.
;;;335    	// calculte the udp length:
;;;336    	buf[UDP_LEN_H_P]=datalen>>8;
000032  0a30              LSRS     r0,r6,#8
000034  70a0              STRB     r0,[r4,#2]
;;;337    	buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
000036  f1060008          ADD      r0,r6,#8
00003a  70e0              STRB     r0,[r4,#3]
;;;338    	// zero the checksum
;;;339    	buf[UDP_CHECKSUM_H_P]=0;
00003c  2000              MOVS     r0,#0
00003e  7120              STRB     r0,[r4,#4]
;;;340    	buf[UDP_CHECKSUM_L_P]=0;
000040  7160              STRB     r0,[r4,#5]
000042  3c24              SUBS     r4,r4,#0x24
;;;341    	// copy the data:
;;;342    	while(i<datalen)
000044  e006              B        |L18.84|
                  |L18.70|
;;;343    		{
;;;344            buf[UDP_DATA_P+i]=data[i];
000046  f8151008          LDRB     r1,[r5,r8]
00004a  f108002a          ADD      r0,r8,#0x2a
00004e  5421              STRB     r1,[r4,r0]
;;;345            i++;
000050  f1080801          ADD      r8,r8,#1
                  |L18.84|
000054  45b0              CMP      r8,r6                 ;342
000056  d3f6              BCC      |L18.70|
;;;346    		}
;;;347    	ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
000058  f1060110          ADD      r1,r6,#0x10
00005c  2201              MOVS     r2,#1
00005e  f104001a          ADD      r0,r4,#0x1a
000062  f7fffffe          BL       checksum
000066  4681              MOV      r9,r0
;;;348    	buf[UDP_CHECKSUM_H_P]=ck>>8;
000068  ea4f2019          LSR      r0,r9,#8
00006c  f8840028          STRB     r0,[r4,#0x28]
;;;349    	buf[UDP_CHECKSUM_L_P]=ck& 0xff;
000070  f8849029          STRB     r9,[r4,#0x29]
;;;350    	enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
000074  f106002a          ADD      r0,r6,#0x2a
000078  4621              MOV      r1,r4
00007a  f7fffffe          BL       enc28j60PacketSend
;;;351    	}
00007e  e8bd87f0          POP      {r4-r10,pc}
;;;352    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  wwwport
000000  50000000          DCB      0x50,0x00,0x00,0x00
                  info_hdr_len
                          DCD      0x00000000
                  info_data_len
                          DCD      0x00000000
                  seqnum
00000c  0a                DCB      0x0a
                  macaddr
                          DCDU     0x00000000
000011  0000              DCB      0x00,0x00
                  ipaddr
                          DCDU     0x00000000
