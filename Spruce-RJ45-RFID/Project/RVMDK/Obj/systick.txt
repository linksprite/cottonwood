; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\systick.o --depend=.\Obj\systick.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\systick.crf ..\..\Source\src\systick.c]
                          THUMB

                          AREA ||i.CheckTimer||, CODE, READONLY, ALIGN=2

                  CheckTimer PROC
;;;131    */
;;;132    uint8_t CheckTimer(uint8_t _id)
000000  4601              MOV      r1,r0
;;;133    {
;;;134    	if (_id >= TMR_COUNT)
000002  2904              CMP      r1,#4
000004  db01              BLT      |L1.10|
;;;135    	{
;;;136    		return 0;
000006  2000              MOVS     r0,#0
                  |L1.8|
;;;137    	}
;;;138    
;;;139    	return g_Tmr[_id].flag;
;;;140    }
000008  4770              BX       lr
                  |L1.10|
00000a  4802              LDR      r0,|L1.20|
00000c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;139
000010  7900              LDRB     r0,[r0,#4]            ;139
000012  e7f9              B        |L1.8|
;;;141    
                          ENDP

                  |L1.20|
                          DCD      g_Tmr

                          AREA ||i.DelayMS||, CODE, READONLY, ALIGN=2

                  DelayMS PROC
;;;86     */
;;;87     void DelayMS(uint32_t n)
000000  2801              CMP      r0,#1
;;;88     {
;;;89     	/* 避免 n = 1 出现主程序死锁 */
;;;90     	if (n == 1)
000002  d100              BNE      |L2.6|
;;;91     	{
;;;92     		n = 2;
000004  2002              MOVS     r0,#2
                  |L2.6|
;;;93     	}
;;;94     	g_Tmr[0].count = n;
000006  4907              LDR      r1,|L2.36|
000008  6008              STR      r0,[r1,#0]  ; g_Tmr
;;;95     	g_Tmr[0].flag = 0;
00000a  2100              MOVS     r1,#0
00000c  4a05              LDR      r2,|L2.36|
00000e  7111              STRB     r1,[r2,#4]
;;;96     
;;;97     	/* while 循环体最好让CPU进入IDLE状态，已降低功耗 */
;;;98     	while (1)
000010  e004              B        |L2.28|
                  |L2.18|
;;;99     	{
;;;100    		CPU_IDLE();
;;;101    
;;;102    		if (g_Tmr[0].flag == 1)
000012  4904              LDR      r1,|L2.36|
000014  7909              LDRB     r1,[r1,#4]  ; g_Tmr
000016  2901              CMP      r1,#1
000018  d100              BNE      |L2.28|
;;;103    		{
;;;104    			break;
00001a  e000              B        |L2.30|
                  |L2.28|
00001c  e7f9              B        |L2.18|
                  |L2.30|
00001e  bf00              NOP      
;;;105    		}
;;;106    	}
;;;107    }
000020  4770              BX       lr
;;;108    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      g_Tmr

                          AREA ||i.GetRunTime||, CODE, READONLY, ALIGN=2

                  GetRunTime PROC
;;;147    */
;;;148    int32_t GetRunTime(void)
000000  bf00              NOP      
000002  2101              MOVS     r1,#1
000004  f3818810          MSR      PRIMASK,r1
000008  bf00              NOP      
;;;149    {
;;;150    	int runtime; 
;;;151    
;;;152    	__set_PRIMASK(1);  		/* 关中断 */
;;;153    	
;;;154    	runtime = g_RunTime;	/* 由于在Systick中断被改写，因此关中断进行保护 */
00000a  4904              LDR      r1,|L3.28|
00000c  6808              LDR      r0,[r1,#0]  ; g_RunTime
;;;155    		
;;;156    	__set_PRIMASK(0);  		/* 开中断 */
00000e  bf00              NOP      
000010  2100              MOVS     r1,#0
000012  f3818810          MSR      PRIMASK,r1
000016  bf00              NOP      
;;;157    
;;;158    	return runtime;
;;;159    }
000018  4770              BX       lr
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      g_RunTime

                          AREA ||i.SoftTimerDec||, CODE, READONLY, ALIGN=1

                  SoftTimerDec PROC
;;;32     */
;;;33     static void SoftTimerDec(SOFT_TMR *_tmr)
000000  7901              LDRB     r1,[r0,#4]
;;;34     {
;;;35     	if (_tmr->flag == 0)
000002  b939              CBNZ     r1,|L4.20|
;;;36     	{
;;;37     		if (_tmr->count > 0)
000004  6801              LDR      r1,[r0,#0]
000006  b129              CBZ      r1,|L4.20|
;;;38     		{
;;;39     			if (--_tmr->count == 0)
000008  6801              LDR      r1,[r0,#0]
00000a  1e49              SUBS     r1,r1,#1
00000c  6001              STR      r1,[r0,#0]
00000e  d101              BNE      |L4.20|
;;;40     			{
;;;41     				_tmr->flag = 1;
000010  2101              MOVS     r1,#1
000012  7101              STRB     r1,[r0,#4]
                  |L4.20|
;;;42     			}
;;;43     		}
;;;44     	}
;;;45     }
000014  4770              BX       lr
;;;46     
                          ENDP


                          AREA ||i.StartTimer||, CODE, READONLY, ALIGN=2

                  StartTimer PROC
;;;114    */
;;;115    void StartTimer(uint8_t _id, uint32_t _period)
000000  2804              CMP      r0,#4
;;;116    {
;;;117    	if (_id >= TMR_COUNT)
000002  db00              BLT      |L5.6|
                  |L5.4|
;;;118    	{
;;;119    		return;
;;;120    	}
;;;121    
;;;122    	g_Tmr[_id].count = _period;
;;;123    	g_Tmr[_id].flag = 0;
;;;124    }
000004  4770              BX       lr
                  |L5.6|
000006  4a04              LDR      r2,|L5.24|
000008  f8421030          STR      r1,[r2,r0,LSL #3]     ;122
00000c  2200              MOVS     r2,#0                 ;123
00000e  4b02              LDR      r3,|L5.24|
000010  eb0303c0          ADD      r3,r3,r0,LSL #3       ;123
000014  711a              STRB     r2,[r3,#4]            ;123
000016  e7f5              B        |L5.4|
;;;125    
                          ENDP

                  |L5.24|
                          DCD      g_Tmr

                          AREA ||i.SysTick_ISR||, CODE, READONLY, ALIGN=2

                  SysTick_ISR PROC
;;;52     */
;;;53     void SysTick_ISR(void)
000000  b510              PUSH     {r4,lr}
;;;54     {
;;;55     	static uint8_t s_count = 0;
;;;56     	uint8_t i;
;;;57     
;;;58     	for (i = 0; i < TMR_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e006              B        |L6.20|
                  |L6.6|
;;;59     	{
;;;60     		SoftTimerDec(&g_Tmr[i]);
000006  4910              LDR      r1,|L6.72|
000008  eb0100c4          ADD      r0,r1,r4,LSL #3
00000c  f7fffffe          BL       SoftTimerDec
000010  1c60              ADDS     r0,r4,#1              ;58
000012  b2c4              UXTB     r4,r0                 ;58
                  |L6.20|
000014  2c04              CMP      r4,#4                 ;58
000016  dbf6              BLT      |L6.6|
;;;61     	}
;;;62     
;;;63     	/* 下面的代码实现所有按键的检测
;;;64     		按键检测每隔10ms一次就行了，一般做40ms的滤波处理就可以有效过滤掉机械动作造成的
;;;65     		按键抖动。
;;;66     	*/
;;;67     	if (++s_count >= 10)
000018  480c              LDR      r0,|L6.76|
00001a  7800              LDRB     r0,[r0,#0]  ; s_count
00001c  1c40              ADDS     r0,r0,#1
00001e  b2c0              UXTB     r0,r0
000020  490a              LDR      r1,|L6.76|
000022  7008              STRB     r0,[r1,#0]
000024  280a              CMP      r0,#0xa
000026  db0d              BLT      |L6.68|
;;;68     	{
;;;69     		s_count = 0;
000028  2000              MOVS     r0,#0
00002a  7008              STRB     r0,[r1,#0]
;;;70     
;;;71     		g_RunTime++;	/* 全局运行时间每10ms增1 */	
00002c  4808              LDR      r0,|L6.80|
00002e  6800              LDR      r0,[r0,#0]  ; g_RunTime
000030  1c40              ADDS     r0,r0,#1
000032  4907              LDR      r1,|L6.80|
000034  6008              STR      r0,[r1,#0]  ; g_RunTime
;;;72     		if (g_RunTime == 0x80000000)
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]  ; g_RunTime
00003a  f1b04f00          CMP      r0,#0x80000000
00003e  d101              BNE      |L6.68|
;;;73     		{
;;;74     			g_RunTime = 0;
000040  2000              MOVS     r0,#0
000042  6008              STR      r0,[r1,#0]  ; g_RunTime
                  |L6.68|
;;;75     		}
;;;76     		
;;;77     		
;;;78     	}
;;;79     }
000044  bd10              POP      {r4,pc}
;;;80     
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      g_Tmr
                  |L6.76|
                          DCD      ||.data||+0x4
                  |L6.80|
                          DCD      g_RunTime

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Tmr
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  g_RunTime
                          DCD      0x00000000
                  s_count
000004  00                DCB      0x00
