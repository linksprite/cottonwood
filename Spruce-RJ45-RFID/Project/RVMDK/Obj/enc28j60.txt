; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\enc28j60.o --depend=.\Obj\enc28j60.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\enc28j60.crf ..\..\Source\src\uIP_enc28j60\ENC28J60.C]
                          THUMB

                          AREA ||i.enc28j60Init||, CODE, READONLY, ALIGN=2

                  enc28j60Init PROC
;;;122    
;;;123    void enc28j60Init(unsigned char* macaddr)
000000  b570              PUSH     {r4-r6,lr}
;;;124    	{unsigned char a=0;   
000002  4604              MOV      r4,r0
000004  2500              MOVS     r5,#0
;;;125    	// initialize I/O
;;;126    	//enc28j60CSinit();
;;;127    	ENC28J60_CSH();	      
000006  2010              MOVS     r0,#0x10
000008  494c              LDR      r1,|L1.316|
00000a  6008              STR      r0,[r1,#0]
;;;128    
;;;129        //enc28j60SetSCK();
;;;130        //enc28j60HWreset();
;;;131    	// perform system reset
;;;132    	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
00000c  22ff              MOVS     r2,#0xff
00000e  2100              MOVS     r1,#0
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       enc28j60WriteOp
;;;133    //	Del_1ms(250);
;;;134    	// check CLKRDY bit to see if reset is complete
;;;135            // The CLKRDY does not work. See Rev. B4 Silicon Errata point. Just wait.
;;;136    	//while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
;;;137    	// do bank 0 stuff
;;;138    	// initialize receive buffer
;;;139    	// 16-bit transfers, must write low byte first
;;;140    	// set receive buffer start address	   设置接收缓冲区地址  8K字节容量
;;;141    	NextPacketPtr = RXSTART_INIT;
000016  2000              MOVS     r0,#0
000018  4949              LDR      r1,|L1.320|
00001a  6008              STR      r0,[r1,#0]  ; NextPacketPtr
;;;142            // Rx start
;;;143    	//接收缓冲器由一个硬件管理的循环FIFO 缓冲器构成。
;;;144    //寄存器对ERXSTH:ERXSTL 和ERXNDH:ERXNDL 作
;;;145    //为指针，定义缓冲器的容量和其在存储器中的位置。
;;;146    //ERXST和ERXND指向的字节均包含在FIFO缓冲器内。
;;;147    //当从以太网接口接收数据字节时，这些字节被顺序写入
;;;148    //接收缓冲器。 但是当写入由ERXND 指向的存储单元
;;;149    //后，硬件会自动将接收的下一字节写入由ERXST 指向
;;;150    //的存储单元。 因此接收硬件将不会写入FIFO 以外的单
;;;151    //元。
;;;152    	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);	 //
00001c  2100              MOVS     r1,#0
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       enc28j60Write
;;;153    	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
000024  2100              MOVS     r1,#0
000026  2009              MOVS     r0,#9
000028  f7fffffe          BL       enc28j60Write
;;;154    	// set receive pointer address
;;;155    	//ERXWRPTH:ERXWRPTL 寄存器定义硬件向FIFO 中
;;;156        //的哪个位置写入其接收到的字节。 指针是只读的，在成
;;;157        //功接收到一个数据包后，硬件会自动更新指针。 指针可
;;;158        //用于判断FIFO 内剩余空间的大小  8K-1500。 
;;;159    	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
00002c  2100              MOVS     r1,#0
00002e  200c              MOVS     r0,#0xc
000030  f7fffffe          BL       enc28j60Write
;;;160    	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
000034  2100              MOVS     r1,#0
000036  200d              MOVS     r0,#0xd
000038  f7fffffe          BL       enc28j60Write
;;;161    	// RX end
;;;162    	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
00003c  21fe              MOVS     r1,#0xfe
00003e  200a              MOVS     r0,#0xa
000040  f7fffffe          BL       enc28j60Write
;;;163    	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
000044  2119              MOVS     r1,#0x19
000046  200b              MOVS     r0,#0xb
000048  f7fffffe          BL       enc28j60Write
;;;164    	// TX start	  1500
;;;165    	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
00004c  21ff              MOVS     r1,#0xff
00004e  2004              MOVS     r0,#4
000050  f7fffffe          BL       enc28j60Write
;;;166    	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
000054  2119              MOVS     r1,#0x19
000056  2005              MOVS     r0,#5
000058  f7fffffe          BL       enc28j60Write
;;;167    	// TX end
;;;168    	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
00005c  21ff              MOVS     r1,#0xff
00005e  2006              MOVS     r0,#6
000060  f7fffffe          BL       enc28j60Write
;;;169    	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
000064  211f              MOVS     r1,#0x1f
000066  2007              MOVS     r0,#7
000068  f7fffffe          BL       enc28j60Write
;;;170    	// do bank 1 stuff, packet filter:
;;;171            // For broadcast packets we allow only ARP packtets
;;;172            // All other packets should be unicast only for our mac (MAADR)
;;;173            //
;;;174            // The pattern to match on is therefore
;;;175            // Type     ETH.DST
;;;176            // ARP      BROADCAST
;;;177            // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
;;;178            // in binary these poitions are:11 0000 0011 1111
;;;179            // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
;;;180        //接收过滤器
;;;181    	//UCEN：单播过滤器使能位
;;;182        //当ANDOR = 1 时：
;;;183    	//1 = 目标地址与本地MAC 地址不匹配的数据包将被丢弃
;;;184    	//0 = 禁止过滤器
;;;185    	//当ANDOR = 0 时：
;;;186    	//1 = 目标地址与本地MAC 地址匹配的数据包会被接受
;;;187    	//0 = 禁止过滤器
;;;188    
;;;189        //CRCEN：后过滤器CRC 校验使能位
;;;190    	//1 = 所有CRC 无效的数据包都将被丢弃
;;;191    	//0 = 不考虑CRC 是否有效
;;;192    	
;;;193    	//PMEN：格式匹配过滤器使能位
;;;194    	//当ANDOR = 1 时：
;;;195    	//1 = 数据包必须符合格式匹配条件，否则将被丢弃
;;;196    	//0 = 禁止过滤器
;;;197    	//当ANDOR = 0 时：
;;;198    	//1 = 符合格式匹配条件的数据包将被接受
;;;199    	//0 = 禁止过滤器
;;;200    	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
00006c  21b0              MOVS     r1,#0xb0
00006e  2038              MOVS     r0,#0x38
000070  f7fffffe          BL       enc28j60Write
;;;201    	enc28j60Write(EPMM0, 0x3f);
000074  213f              MOVS     r1,#0x3f
000076  2028              MOVS     r0,#0x28
000078  f7fffffe          BL       enc28j60Write
;;;202    	enc28j60Write(EPMM1, 0x30);
00007c  2130              MOVS     r1,#0x30
00007e  2029              MOVS     r0,#0x29
000080  f7fffffe          BL       enc28j60Write
;;;203    	enc28j60Write(EPMCSL, 0xf9);
000084  21f9              MOVS     r1,#0xf9
000086  2030              MOVS     r0,#0x30
000088  f7fffffe          BL       enc28j60Write
;;;204    	enc28j60Write(EPMCSH, 0xf7);
00008c  21f7              MOVS     r1,#0xf7
00008e  2031              MOVS     r0,#0x31
000090  f7fffffe          BL       enc28j60Write
;;;205            //
;;;206            //
;;;207    	// do bank 2 stuff
;;;208    	// enable MAC receive
;;;209    	//bit 0 MARXEN：MAC 接收使能位
;;;210    		//1 = 允许MAC 接收数据包
;;;211    		//0 = 禁止数据包接收
;;;212    	//bit 3 TXPAUS：暂停控制帧发送使能位
;;;213    		//1 = 允许MAC 发送暂停控制帧（用于全双工模式下的流量控制）
;;;214    		//0 = 禁止暂停帧发送
;;;215    	//bit 2 RXPAUS：暂停控制帧接收使能位
;;;216    		//1 = 当接收到暂停控制帧时，禁止发送（正常操作）
;;;217    		//0 = 忽略接收到的暂停控制帧
;;;218    	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
000094  210d              MOVS     r1,#0xd
000096  20c0              MOVS     r0,#0xc0
000098  f7fffffe          BL       enc28j60Write
;;;219    	// bring MAC out of reset
;;;220    	//将MACON2 中的MARST 位清零，使MAC 退出复位状态。
;;;221    	enc28j60Write(MACON2, 0x00);
00009c  2100              MOVS     r1,#0
00009e  20c1              MOVS     r0,#0xc1
0000a0  f7fffffe          BL       enc28j60Write
;;;222    	// enable automatic padding to 60bytes and CRC operations
;;;223    	//bit 7-5 PADCFG2:PACDFG0：自动填充和CRC 配置位
;;;224    		//111 = 用0 填充所有短帧至64 字节长，并追加一个有效的CRC
;;;225    		//110 = 不自动填充短帧
;;;226    		//101 = MAC 自动检测具有8100h 类型字段的VLAN 协议帧，并自动填充到64 字节长。如果不
;;;227    		//是VLAN 帧，则填充至60 字节长。填充后还要追加一个有效的CRC
;;;228    		//100 = 不自动填充短帧
;;;229    		//011 = 用0 填充所有短帧至64 字节长，并追加一个有效的CRC
;;;230    		//010 = 不自动填充短帧
;;;231    		//001 = 用0 填充所有短帧至60 字节长，并追加一个有效的CRC
;;;232    		//000 = 不自动填充短帧
;;;233    	//bit 4 TXCRCEN：发送CRC 使能位
;;;234    		//1 = 不管PADCFG如何，MAC都会在发送帧的末尾追加一个有效的CRC。 如果PADCFG规定要
;;;235    		//追加有效的CRC，则必须将TXCRCEN 置1。
;;;236    		//0 = MAC不会追加CRC。 检查最后4 个字节，如果不是有效的CRC 则报告给发送状态向量。
;;;237    	//bit 0 FULDPX：MAC 全双工使能位
;;;238    		//1 = MAC工作在全双工模式下。 PHCON1.PDPXMD 位必须置1。
;;;239    		//0 = MAC工作在半双工模式下。 PHCON1.PDPXMD 位必须清零。
;;;240    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN|MACON3_FULDPX);
0000a4  2233              MOVS     r2,#0x33
0000a6  21c2              MOVS     r1,#0xc2
0000a8  2080              MOVS     r0,#0x80
0000aa  f7fffffe          BL       enc28j60WriteOp
;;;241    	// set inter-frame gap (non-back-to-back)
;;;242    	//配置非背对背包间间隔寄存器的低字节
;;;243    	//MAIPGL。 大多数应用使用12h 编程该寄存器。
;;;244    	//如果使用半双工模式，应编程非背对背包间间隔
;;;245    	//寄存器的高字节MAIPGH。 大多数应用使用0Ch
;;;246    	//编程该寄存器。
;;;247    	enc28j60Write(MAIPGL, 0x12);
0000ae  2112              MOVS     r1,#0x12
0000b0  20c6              MOVS     r0,#0xc6
0000b2  f7fffffe          BL       enc28j60Write
;;;248    	enc28j60Write(MAIPGH, 0x0C);
0000b6  210c              MOVS     r1,#0xc
0000b8  20c7              MOVS     r0,#0xc7
0000ba  f7fffffe          BL       enc28j60Write
;;;249    	// set inter-frame gap (back-to-back)
;;;250    	//配置背对背包间间隔寄存器MABBIPG。当使用
;;;251    	//全双工模式时，大多数应用使用15h 编程该寄存
;;;252    	//器，而使用半双工模式时则使用12h 进行编程。
;;;253    	enc28j60Write(MABBIPG, 0x15);
0000be  2115              MOVS     r1,#0x15
0000c0  20c4              MOVS     r0,#0xc4
0000c2  f7fffffe          BL       enc28j60Write
;;;254    	// Set the maximum packet size which the controller will accept
;;;255        // Do not send packets longer than MAX_FRAMELEN:
;;;256    	// 最大帧长度  1500
;;;257    	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
0000c6  21dc              MOVS     r1,#0xdc
0000c8  20ca              MOVS     r0,#0xca
0000ca  f7fffffe          BL       enc28j60Write
;;;258    	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
0000ce  2105              MOVS     r1,#5
0000d0  20cb              MOVS     r0,#0xcb
0000d2  f7fffffe          BL       enc28j60Write
;;;259    	// do bank 3 stuff
;;;260    	// write MAC address
;;;261    	// NOTE: MAC address in ENC28J60 is byte-backward
;;;262    	enc28j60Write(MAADR5, macaddr[0]);	
0000d6  7821              LDRB     r1,[r4,#0]
0000d8  20e4              MOVS     r0,#0xe4
0000da  f7fffffe          BL       enc28j60Write
;;;263    	enc28j60Write(MAADR4, macaddr[1]);
0000de  7861              LDRB     r1,[r4,#1]
0000e0  20e5              MOVS     r0,#0xe5
0000e2  f7fffffe          BL       enc28j60Write
;;;264    	enc28j60Write(MAADR3, macaddr[2]);
0000e6  78a1              LDRB     r1,[r4,#2]
0000e8  20e2              MOVS     r0,#0xe2
0000ea  f7fffffe          BL       enc28j60Write
;;;265    	enc28j60Write(MAADR2, macaddr[3]);
0000ee  78e1              LDRB     r1,[r4,#3]
0000f0  20e3              MOVS     r0,#0xe3
0000f2  f7fffffe          BL       enc28j60Write
;;;266    	enc28j60Write(MAADR1, macaddr[4]);
0000f6  7921              LDRB     r1,[r4,#4]
0000f8  20e0              MOVS     r0,#0xe0
0000fa  f7fffffe          BL       enc28j60Write
;;;267    	enc28j60Write(MAADR0, macaddr[5]);
0000fe  7961              LDRB     r1,[r4,#5]
000100  20e1              MOVS     r0,#0xe1
000102  f7fffffe          BL       enc28j60Write
;;;268    	if(enc28j60Read(MAADR5)== macaddr[0]){
000106  20e4              MOVS     r0,#0xe4
000108  f7fffffe          BL       enc28j60Read
;;;269    //	printf("MAADR5 = 0x%x\r\n", enc28j60Read(MAADR5));
;;;270    //	printf("MAADR4 = 0x%x\r\n", enc28j60Read(MAADR4));
;;;271    //	printf("MAADR3 = 0x%x\r\n", enc28j60Read(MAADR3));
;;;272    //	printf("MAADR2 = 0x%x\r\n", enc28j60Read(MAADR2));
;;;273    //	printf("MAADR1 = 0x%x\r\n", enc28j60Read(MAADR1));
;;;274    //	printf("MAADR0 = 0x%x\r\n", enc28j60Read(MAADR0));
;;;275    	}
;;;276    	//配置PHY为全双工  LEDB为拉电流
;;;277    	enc28j60PhyWrite(PHCON1, PHCON1_PDPXMD);
00010c  f44f7180          MOV      r1,#0x100
000110  2000              MOVS     r0,#0
000112  f7fffffe          BL       enc28j60PhyWrite
;;;278    
;;;279    
;;;280    	// no loopback of transmitted frames	 禁止环回
;;;281        //HDLDIS：PHY 半双工环回禁止位
;;;282    		//当PHCON1.PDPXMD = 1 或PHCON1.PLOOPBK = 1 时：
;;;283    		//此位可被忽略。
;;;284    		//当PHCON1.PDPXMD = 0 且PHCON1.PLOOPBK = 0 时：
;;;285    		//1 = 要发送的数据仅通过双绞线接口发出
;;;286    		//0 = 要发送的数据会环回到MAC 并通过双绞线接口发出
;;;287    	enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
000116  f44f7180          MOV      r1,#0x100
00011a  2010              MOVS     r0,#0x10
00011c  f7fffffe          BL       enc28j60PhyWrite
;;;288    	// switch to bank 0
;;;289    	//ECON1 寄存器
;;;290    		//寄存器3-1 所示为ECON1 寄存器，它用于控制
;;;291    		//ENC28J60 的主要功能。 ECON1 中包含接收使能、发
;;;292    		//送请求、DMA 控制和存储区选择位。
;;;293    	
;;;294    	enc28j60SetBank(ECON1);
000120  201f              MOVS     r0,#0x1f
000122  f7fffffe          BL       enc28j60SetBank
;;;295    	// enable interrutps
;;;296    	//EIE： 以太网中断允许寄存器
;;;297    	//bit 7 INTIE： 全局INT 中断允许位
;;;298    		//1 = 允许中断事件驱动INT 引脚
;;;299    		//0 = 禁止所有INT 引脚的活动（引脚始终被驱动为高电平）
;;;300    	//bit 6 PKTIE： 接收数据包待处理中断允许位
;;;301    		//1 = 允许接收数据包待处理中断
;;;302    		//0 = 禁止接收数据包待处理中断
;;;303    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
000126  22c0              MOVS     r2,#0xc0
000128  211b              MOVS     r1,#0x1b
00012a  2080              MOVS     r0,#0x80
00012c  f7fffffe          BL       enc28j60WriteOp
;;;304    	// enable packet reception
;;;305    	//bit 2 RXEN：接收使能位
;;;306    		//1 = 通过当前过滤器的数据包将被写入接收缓冲器
;;;307    		//0 = 忽略所有接收的数据包
;;;308    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
000130  2204              MOVS     r2,#4
000132  211f              MOVS     r1,#0x1f
000134  2080              MOVS     r0,#0x80
000136  f7fffffe          BL       enc28j60WriteOp
;;;309    	}
00013a  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP

                  |L1.316|
                          DCD      0x40010810
                  |L1.320|
                          DCD      ||.data||+0x4

                          AREA ||i.enc28j60PacketReceive||, CODE, READONLY, ALIGN=2

                  enc28j60PacketReceive PROC
;;;350    // Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
;;;351    unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;352    	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;353    	unsigned int rxstat;
;;;354    	unsigned int len;
;;;355    
;;;356    	// check if a packet has been received and buffered
;;;357    	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
;;;358            // The above does not work. See Rev. B4 Silicon Errata point 6.
;;;359    	if( enc28j60Read(EPKTCNT) ==0 )  //收到的以太网数据包长度
000008  2039              MOVS     r0,#0x39
00000a  f7fffffe          BL       enc28j60Read
00000e  b910              CBNZ     r0,|L2.22|
;;;360    		{
;;;361    		return(0);
000010  2000              MOVS     r0,#0
                  |L2.18|
;;;362            }
;;;363    
;;;364    	// Set the read pointer to the start of the received packet		 缓冲器读指针
;;;365    	enc28j60Write(ERDPTL, (NextPacketPtr));
;;;366    	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
;;;367    
;;;368    	// read the next packet pointer
;;;369    	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
;;;370    	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
;;;371    
;;;372    	// read the packet length (see datasheet page 43)
;;;373    	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
;;;374    	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
;;;375    
;;;376        len-=4; //remove the CRC count
;;;377    	// read the receive status (see datasheet page 43)
;;;378    	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
;;;379    	rxstat |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
;;;380    	// limit retrieve length
;;;381        if (len>maxlen-1)
;;;382    		{
;;;383            len=maxlen-1;
;;;384        	}
;;;385    
;;;386            // check CRC and symbol errors (see datasheet page 44, table 7-3):
;;;387            // The ERXFCON.CRCEN is set by default. Normally we should not
;;;388            // need to check this.
;;;389        if ((rxstat & 0x80)==0)
;;;390    			{
;;;391    		    // invalid
;;;392    		    len=0;
;;;393    		    }
;;;394    		else
;;;395    			{
;;;396                // copy the packet from the receive buffer
;;;397                enc28j60ReadBuffer(len, packet);
;;;398            	}
;;;399    	// Move the RX read pointer to the start of the next received packet
;;;400    	// This frees the memory we just read out
;;;401    	enc28j60Write(ERXRDPTL, (NextPacketPtr));
;;;402    	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
;;;403    
;;;404    	// decrement the packet counter indicate we are done with this packet
;;;405    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
;;;406    	return(len);
;;;407    	}
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L2.22|
000016  482a              LDR      r0,|L2.192|
000018  6800              LDR      r0,[r0,#0]            ;365  ; NextPacketPtr
00001a  b2c1              UXTB     r1,r0                 ;365
00001c  2000              MOVS     r0,#0                 ;365
00001e  f7fffffe          BL       enc28j60Write
000022  4827              LDR      r0,|L2.192|
000024  6800              LDR      r0,[r0,#0]            ;366  ; NextPacketPtr
000026  f3c02107          UBFX     r1,r0,#8,#8           ;366
00002a  2001              MOVS     r0,#1                 ;366
00002c  f7fffffe          BL       enc28j60Write
000030  2100              MOVS     r1,#0                 ;369
000032  203a              MOVS     r0,#0x3a              ;369
000034  f7fffffe          BL       enc28j60ReadOp
000038  4921              LDR      r1,|L2.192|
00003a  6008              STR      r0,[r1,#0]            ;369  ; NextPacketPtr
00003c  2100              MOVS     r1,#0                 ;370
00003e  203a              MOVS     r0,#0x3a              ;370
000040  f7fffffe          BL       enc28j60ReadOp
000044  491e              LDR      r1,|L2.192|
000046  6809              LDR      r1,[r1,#0]            ;370  ; NextPacketPtr
000048  ea412000          ORR      r0,r1,r0,LSL #8       ;370
00004c  491c              LDR      r1,|L2.192|
00004e  6008              STR      r0,[r1,#0]            ;370  ; NextPacketPtr
000050  2100              MOVS     r1,#0                 ;373
000052  203a              MOVS     r0,#0x3a              ;373
000054  f7fffffe          BL       enc28j60ReadOp
000058  4607              MOV      r7,r0                 ;373
00005a  2100              MOVS     r1,#0                 ;374
00005c  203a              MOVS     r0,#0x3a              ;374
00005e  f7fffffe          BL       enc28j60ReadOp
000062  ea472700          ORR      r7,r7,r0,LSL #8       ;374
000066  1f3f              SUBS     r7,r7,#4              ;376
000068  2100              MOVS     r1,#0                 ;378
00006a  203a              MOVS     r0,#0x3a              ;378
00006c  f7fffffe          BL       enc28j60ReadOp
000070  4606              MOV      r6,r0                 ;378
000072  2100              MOVS     r1,#0                 ;379
000074  203a              MOVS     r0,#0x3a              ;379
000076  f7fffffe          BL       enc28j60ReadOp
00007a  ea462600          ORR      r6,r6,r0,LSL #8       ;379
00007e  1e60              SUBS     r0,r4,#1              ;381
000080  42b8              CMP      r0,r7                 ;381
000082  d200              BCS      |L2.134|
000084  1e67              SUBS     r7,r4,#1              ;383
                  |L2.134|
000086  f0160f80          TST      r6,#0x80              ;389
00008a  d101              BNE      |L2.144|
00008c  2700              MOVS     r7,#0                 ;392
00008e  e003              B        |L2.152|
                  |L2.144|
000090  4629              MOV      r1,r5                 ;397
000092  4638              MOV      r0,r7                 ;397
000094  f7fffffe          BL       enc28j60ReadBuffer
                  |L2.152|
000098  4809              LDR      r0,|L2.192|
00009a  6800              LDR      r0,[r0,#0]            ;401  ; NextPacketPtr
00009c  b2c1              UXTB     r1,r0                 ;401
00009e  200c              MOVS     r0,#0xc               ;401
0000a0  f7fffffe          BL       enc28j60Write
0000a4  4806              LDR      r0,|L2.192|
0000a6  6800              LDR      r0,[r0,#0]            ;402  ; NextPacketPtr
0000a8  f3c02107          UBFX     r1,r0,#8,#8           ;402
0000ac  200d              MOVS     r0,#0xd               ;402
0000ae  f7fffffe          BL       enc28j60Write
0000b2  2240              MOVS     r2,#0x40              ;405
0000b4  211e              MOVS     r1,#0x1e              ;405
0000b6  2080              MOVS     r0,#0x80              ;405
0000b8  f7fffffe          BL       enc28j60WriteOp
0000bc  4638              MOV      r0,r7                 ;406
0000be  e7a8              B        |L2.18|
;;;408    
                          ENDP

                  |L2.192|
                          DCD      ||.data||+0x4

                          AREA ||i.enc28j60PacketSend||, CODE, READONLY, ALIGN=1

                  enc28j60PacketSend PROC
;;;319    
;;;320    void enc28j60PacketSend(unsigned int len, unsigned char* packet)
000000  b570              PUSH     {r4-r6,lr}
;;;321    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;322    	// Set the write pointer to start of transmit buffer area
;;;323    	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
000006  21ff              MOVS     r1,#0xff
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       enc28j60Write
;;;324    	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
00000e  2119              MOVS     r1,#0x19
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       enc28j60Write
;;;325    
;;;326    	// Set the TXND pointer to correspond to the packet size given
;;;327    	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
000016  20ff              MOVS     r0,#0xff
000018  4420              ADD      r0,r0,r4
00001a  b2c1              UXTB     r1,r0
00001c  2006              MOVS     r0,#6
00001e  f7fffffe          BL       enc28j60Write
;;;328    	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
000022  f64110ff          MOV      r0,#0x19ff
000026  4420              ADD      r0,r0,r4
000028  f3c02107          UBFX     r1,r0,#8,#8
00002c  2007              MOVS     r0,#7
00002e  f7fffffe          BL       enc28j60Write
;;;329    
;;;330    	// write per-packet control byte (0x00 means use macon3 settings)
;;;331    	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
000032  2200              MOVS     r2,#0
000034  4611              MOV      r1,r2
000036  207a              MOVS     r0,#0x7a
000038  f7fffffe          BL       enc28j60WriteOp
;;;332    
;;;333    	// copy the packet into the transmit buffer
;;;334    	enc28j60WriteBuffer(len, packet);
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       enc28j60WriteBuffer
;;;335    
;;;336    	// send the contents of the transmit buffer onto the network
;;;337    	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
000044  2208              MOVS     r2,#8
000046  211f              MOVS     r1,#0x1f
000048  2080              MOVS     r0,#0x80
00004a  f7fffffe          BL       enc28j60WriteOp
;;;338    
;;;339        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
;;;340    	if( (enc28j60Read(EIR) & EIR_TXERIF) )
00004e  201c              MOVS     r0,#0x1c
000050  f7fffffe          BL       enc28j60Read
000054  f0100f02          TST      r0,#2
000058  d004              BEQ      |L3.100|
;;;341    		{
;;;342            enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
00005a  2208              MOVS     r2,#8
00005c  211f              MOVS     r1,#0x1f
00005e  20a0              MOVS     r0,#0xa0
000060  f7fffffe          BL       enc28j60WriteOp
                  |L3.100|
;;;343            }
;;;344    	}
000064  bd70              POP      {r4-r6,pc}
;;;345    
                          ENDP


                          AREA ||i.enc28j60PhyWrite||, CODE, READONLY, ALIGN=1

                  enc28j60PhyWrite PROC
;;;101    
;;;102    void enc28j60PhyWrite(unsigned char address, unsigned int data)
000000  b570              PUSH     {r4-r6,lr}
;;;103    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;104    	// set the PHY register address
;;;105    	enc28j60Write(MIREGADR, address);
000006  4621              MOV      r1,r4
000008  20d4              MOVS     r0,#0xd4
00000a  f7fffffe          BL       enc28j60Write
;;;106    	// write the PHY data
;;;107    	enc28j60Write(MIWRL, data);
00000e  b2e9              UXTB     r1,r5
000010  20d6              MOVS     r0,#0xd6
000012  f7fffffe          BL       enc28j60Write
;;;108    	enc28j60Write(MIWRH, data>>8);
000016  f3c52107          UBFX     r1,r5,#8,#8
00001a  20d7              MOVS     r0,#0xd7
00001c  f7fffffe          BL       enc28j60Write
;;;109    	// wait until the PHY write completes
;;;110    	while(enc28j60Read(MISTAT) & MISTAT_BUSY)
000020  bf00              NOP      
                  |L4.34|
000022  20ea              MOVS     r0,#0xea
000024  f7fffffe          BL       enc28j60Read
000028  f0100f01          TST      r0,#1
00002c  d1f9              BNE      |L4.34|
;;;111    		{
;;;112    	    	//Del_10us(1);
;;;113    			//_nop_();
;;;114    		}
;;;115    	}
00002e  bd70              POP      {r4-r6,pc}
;;;116    
                          ENDP


                          AREA ||i.enc28j60Read||, CODE, READONLY, ALIGN=1

                  enc28j60Read PROC
;;;85     
;;;86     unsigned char enc28j60Read(unsigned char address)
000000  b510              PUSH     {r4,lr}
;;;87     	{
000002  4604              MOV      r4,r0
;;;88     	// set the bank
;;;89     	enc28j60SetBank(address);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       enc28j60SetBank
;;;90     	// do the read
;;;91     	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
00000a  4621              MOV      r1,r4
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       enc28j60ReadOp
;;;92     	}
000012  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.enc28j60ReadBuffer||, CODE, READONLY, ALIGN=2

                  enc28j60ReadBuffer PROC
;;;42     
;;;43     void enc28j60ReadBuffer(unsigned int len, unsigned char* data)
000000  b570              PUSH     {r4-r6,lr}
;;;44     	{
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;45     	ENC28J60_CSL();
000006  2010              MOVS     r0,#0x10
000008  490a              LDR      r1,|L6.52|
00000a  6008              STR      r0,[r1,#0]
;;;46     	// issue read command
;;;47     	SPI1_ReadWrite(ENC28J60_READ_BUF_MEM);
00000c  203a              MOVS     r0,#0x3a
00000e  f7fffffe          BL       SPI1_ReadWrite
;;;48     	while(len)
000012  e005              B        |L6.32|
                  |L6.20|
;;;49     		{
;;;50             len--;
000014  1e6d              SUBS     r5,r5,#1
;;;51             // read data
;;;52             *data = (unsigned char)SPI1_ReadWrite(0);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI1_ReadWrite
00001c  7020              STRB     r0,[r4,#0]
;;;53             data++;
00001e  1c64              ADDS     r4,r4,#1
                  |L6.32|
000020  2d00              CMP      r5,#0                 ;48
000022  d1f7              BNE      |L6.20|
;;;54     		}
;;;55     	*data='\0';
000024  2000              MOVS     r0,#0
000026  7020              STRB     r0,[r4,#0]
;;;56     	ENC28J60_CSH();
000028  2010              MOVS     r0,#0x10
00002a  4902              LDR      r1,|L6.52|
00002c  1f09              SUBS     r1,r1,#4
00002e  6008              STR      r0,[r1,#0]
;;;57     	}
000030  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40010814

                          AREA ||i.enc28j60ReadOp||, CODE, READONLY, ALIGN=2

                  enc28j60ReadOp PROC
;;;9      
;;;10     unsigned char enc28j60ReadOp(unsigned char op, unsigned char address)
000000  b570              PUSH     {r4-r6,lr}
;;;11     	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;12     	unsigned char dat = 0;
000006  2600              MOVS     r6,#0
;;;13     	
;;;14     	ENC28J60_CSL();
000008  2010              MOVS     r0,#0x10
00000a  490d              LDR      r1,|L7.64|
00000c  6008              STR      r0,[r1,#0]
;;;15     	
;;;16     	dat = op | (address & ADDR_MASK);
00000e  f005001f          AND      r0,r5,#0x1f
000012  ea400604          ORR      r6,r0,r4
;;;17     	SPI1_ReadWrite(dat);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       SPI1_ReadWrite
;;;18     	dat = SPI1_ReadWrite(0xFF);
00001c  20ff              MOVS     r0,#0xff
00001e  f7fffffe          BL       SPI1_ReadWrite
000022  4606              MOV      r6,r0
;;;19     	// do dummy read if needed (for mac and mii, see datasheet page 29)
;;;20     	if(address & 0x80)
000024  f0150f80          TST      r5,#0x80
000028  d003              BEQ      |L7.50|
;;;21     	    {
;;;22     		dat = SPI1_ReadWrite(0xFF);
00002a  20ff              MOVS     r0,#0xff
00002c  f7fffffe          BL       SPI1_ReadWrite
000030  4606              MOV      r6,r0
                  |L7.50|
;;;23     	    }
;;;24     	// release CS
;;;25     	ENC28J60_CSH();
000032  2010              MOVS     r0,#0x10
000034  4902              LDR      r1,|L7.64|
000036  1f09              SUBS     r1,r1,#4
000038  6008              STR      r0,[r1,#0]
;;;26     	return dat;
00003a  4630              MOV      r0,r6
;;;27     	}
00003c  bd70              POP      {r4-r6,pc}
;;;28     
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x40010814

                          AREA ||i.enc28j60SetBank||, CODE, READONLY, ALIGN=2

                  enc28j60SetBank PROC
;;;73     
;;;74     void enc28j60SetBank(unsigned char address)
000000  b510              PUSH     {r4,lr}
;;;75     	{
000002  4604              MOV      r4,r0
;;;76     	// set the bank (if needed)
;;;77     	if((address & BANK_MASK) != Enc28j60Bank)
000004  f0040060          AND      r0,r4,#0x60
000008  4909              LDR      r1,|L8.48|
00000a  7809              LDRB     r1,[r1,#0]  ; Enc28j60Bank
00000c  4288              CMP      r0,r1
00000e  d00e              BEQ      |L8.46|
;;;78     		{
;;;79             // set the bank
;;;80             enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
000010  2203              MOVS     r2,#3
000012  211f              MOVS     r1,#0x1f
000014  20a0              MOVS     r0,#0xa0
000016  f7fffffe          BL       enc28j60WriteOp
;;;81             enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
00001a  f3c41241          UBFX     r2,r4,#5,#2
00001e  211f              MOVS     r1,#0x1f
000020  2080              MOVS     r0,#0x80
000022  f7fffffe          BL       enc28j60WriteOp
;;;82             Enc28j60Bank = (address & BANK_MASK);
000026  f0040060          AND      r0,r4,#0x60
00002a  4901              LDR      r1,|L8.48|
00002c  7008              STRB     r0,[r1,#0]
                  |L8.46|
;;;83     		}
;;;84     	}
00002e  bd10              POP      {r4,pc}
;;;85     
                          ENDP

                  |L8.48|
                          DCD      ||.data||

                          AREA ||i.enc28j60Write||, CODE, READONLY, ALIGN=1

                  enc28j60Write PROC
;;;93     
;;;94     void enc28j60Write(unsigned char address, unsigned char data)
000000  b570              PUSH     {r4-r6,lr}
;;;95     	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;96     	// set the bank
;;;97     	enc28j60SetBank(address);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       enc28j60SetBank
;;;98     	// do the write
;;;99     	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2040              MOVS     r0,#0x40
000012  f7fffffe          BL       enc28j60WriteOp
;;;100    	}
000016  bd70              POP      {r4-r6,pc}
;;;101    
                          ENDP


                          AREA ||i.enc28j60WriteBuffer||, CODE, READONLY, ALIGN=2

                  enc28j60WriteBuffer PROC
;;;58     
;;;59     void enc28j60WriteBuffer(unsigned int len, unsigned char* data)
000000  b570              PUSH     {r4-r6,lr}
;;;60     	{
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;61     	ENC28J60_CSL();
000006  2010              MOVS     r0,#0x10
000008  4908              LDR      r1,|L10.44|
00000a  6008              STR      r0,[r1,#0]
;;;62     	// issue write command
;;;63     	SPI1_ReadWrite(ENC28J60_WRITE_BUF_MEM);
00000c  207a              MOVS     r0,#0x7a
00000e  f7fffffe          BL       SPI1_ReadWrite
;;;64     	
;;;65     	while(len)
000012  e004              B        |L10.30|
                  |L10.20|
;;;66     		{
;;;67     		len--;
000014  1e6d              SUBS     r5,r5,#1
;;;68     		SPI1_ReadWrite(*data);
000016  7820              LDRB     r0,[r4,#0]
000018  f7fffffe          BL       SPI1_ReadWrite
;;;69     		data++;
00001c  1c64              ADDS     r4,r4,#1
                  |L10.30|
00001e  2d00              CMP      r5,#0                 ;65
000020  d1f8              BNE      |L10.20|
;;;70     		}
;;;71     	ENC28J60_CSH();
000022  2010              MOVS     r0,#0x10
000024  4901              LDR      r1,|L10.44|
000026  1f09              SUBS     r1,r1,#4
000028  6008              STR      r0,[r1,#0]
;;;72     	}
00002a  bd70              POP      {r4-r6,pc}
;;;73     
                          ENDP

                  |L10.44|
                          DCD      0x40010814

                          AREA ||i.enc28j60WriteOp||, CODE, READONLY, ALIGN=2

                  enc28j60WriteOp PROC
;;;28     
;;;29     void enc28j60WriteOp(unsigned char op, unsigned char address, unsigned char data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;30     	{
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;31     	unsigned char dat = 0;
00000a  2700              MOVS     r7,#0
;;;32     	  
;;;33     	ENC28J60_CSL();
00000c  2010              MOVS     r0,#0x10
00000e  4909              LDR      r1,|L11.52|
000010  6008              STR      r0,[r1,#0]
;;;34     	// issue write command
;;;35     	dat = op | (address & ADDR_MASK);
000012  f005001f          AND      r0,r5,#0x1f
000016  ea400704          ORR      r7,r0,r4
;;;36     	SPI1_ReadWrite(dat);
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       SPI1_ReadWrite
;;;37     	// write data
;;;38     	dat = data;
000020  4637              MOV      r7,r6
;;;39     	SPI1_ReadWrite(dat);
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       SPI1_ReadWrite
;;;40     	ENC28J60_CSH();
000028  2010              MOVS     r0,#0x10
00002a  4903              LDR      r1,|L11.56|
00002c  f8c10810          STR      r0,[r1,#0x810]
;;;41     	}
000030  e8bd81f0          POP      {r4-r8,pc}
;;;42     
                          ENDP

                  |L11.52|
                          DCD      0x40010814
                  |L11.56|
                          DCD      0x40010000

                          AREA ||i.enc28j60clkout||, CODE, READONLY, ALIGN=1

                  enc28j60clkout PROC
;;;116    
;;;117    void enc28j60clkout(unsigned char clk)
000000  b510              PUSH     {r4,lr}
;;;118    	{
000002  4604              MOV      r4,r0
;;;119        //setup clkout: 2 is 12.5MHz:
;;;120    	enc28j60Write(ECOCON, clk & 0x7);
000004  f0040107          AND      r1,r4,#7
000008  2075              MOVS     r0,#0x75
00000a  f7fffffe          BL       enc28j60Write
;;;121    	}
00000e  bd10              POP      {r4,pc}
;;;122    
                          ENDP


                          AREA ||i.enc28j60getrev||, CODE, READONLY, ALIGN=1

                  enc28j60getrev PROC
;;;311    // read the revision of the chip:
;;;312    unsigned char enc28j60getrev(void)
000000  b510              PUSH     {r4,lr}
;;;313    	{
;;;314    	//在EREVID 内也存储了版本信息。 EREVID 是一个只读控
;;;315    	//制寄存器，包含一个5 位标识符，用来标识器件特定硅片
;;;316    	//的版本号
;;;317    	return(enc28j60Read(EREVID));
000002  2072              MOVS     r0,#0x72
000004  f7fffffe          BL       enc28j60Read
;;;318    	}
000008  bd10              POP      {r4,pc}
;;;319    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Enc28j60Bank
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  NextPacketPtr
                          DCD      0x00000000
